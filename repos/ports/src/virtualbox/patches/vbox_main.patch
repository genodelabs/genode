vbox_main.patch

From: Christian Prochaska <christian.prochaska@genode-labs.com>


---
 .../virtualbox/src/VBox/Main/include/ConsoleImpl.h |   18 ++-
 .../virtualbox/src/VBox/Main/include/DisplayImpl.h |    8 +
 .../src/VBox/Main/include/FramebufferImpl.h        |    1 
 .../virtualbox/src/VBox/Main/include/MachineImpl.h |    2 
 .../src/VBox/Main/include/NetworkServiceRunner.h   |    5 +
 .../src/VBox/Main/include/ProgressProxyImpl.h      |    2 
 .../virtualbox/src/VBox/Main/include/SessionImpl.h |    4 +
 .../virtualbox/src/VBox/Main/src-all/EventImpl.cpp |   13 ++
 .../VBox/Main/src-all/PCIDeviceAttachmentImpl.cpp  |    4 -
 .../src/VBox/Main/src-all/ProgressImpl.cpp         |   13 +-
 .../src/VBox/Main/src-all/VirtualBoxBase.cpp       |    4 +
 .../VBox/Main/src-client/BusAssignmentManager.cpp  |    2 
 .../src/VBox/Main/src-client/ConsoleImpl.cpp       |  116 +++++++++++++++++++-
 .../src/VBox/Main/src-client/ConsoleImpl2.cpp      |   51 +++++++--
 .../src/VBox/Main/src-client/DisplayImpl.cpp       |   19 +++
 .../src/VBox/Main/src-client/GuestImpl.cpp         |    8 +
 .../src/VBox/Main/src-client/MouseImpl.cpp         |    6 +
 .../src/VBox/Main/src-client/SessionImpl.cpp       |   11 ++
 .../VBox/Main/src-client/VBoxDriversRegister.cpp   |    6 +
 .../src/VBox/Main/src-client/VMMDevInterface.cpp   |    2 
 .../src/VBox/Main/src-server/ClientToken.cpp       |    6 -
 .../src/VBox/Main/src-server/DHCPServerImpl.cpp    |    1 
 .../src/VBox/Main/src-server/MachineImpl.cpp       |   35 ++++--
 .../VBox/Main/src-server/MachineImplCloneVM.cpp    |    2 
 .../src/VBox/Main/src-server/MediumImpl.cpp        |   15 ++-
 .../src/VBox/Main/src-server/MediumLock.cpp        |    2 
 .../VBox/Main/src-server/NetworkAdapterImpl.cpp    |    2 
 .../src/VBox/Main/src-server/SnapshotImpl.cpp      |    3 -
 .../src/VBox/Main/src-server/VRDEServerImpl.cpp    |   11 +-
 .../src/VBox/Main/src-server/VirtualBoxImpl.cpp    |    8 +
 src/app/virtualbox/src/VBox/Main/xml/Settings.cpp  |    4 +
 31 files changed, 311 insertions(+), 73 deletions(-)

diff --git a/src/app/virtualbox/src/VBox/Main/include/ConsoleImpl.h b/src/app/virtualbox/src/VBox/Main/include/ConsoleImpl.h
index 030a601..7fce453 100644
--- a/src/app/virtualbox/src/VBox/Main/include/ConsoleImpl.h
+++ b/src/app/virtualbox/src/VBox/Main/include/ConsoleImpl.h
@@ -50,7 +50,9 @@ class VMMDevMouseInterface;
 class DisplayMouseInterface;
 
 #include <iprt/memsafer.h>
+#if 0
 #include <VBox/RemoteDesktop/VRDE.h>
+#endif /* if 0 */
 #include <VBox/vmm/pdmdrv.h>
 #ifdef VBOX_WITH_GUEST_PROPS
 # include <VBox/HostServices/GuestPropertySvc.h>  /* For the property notification callback */
@@ -251,7 +253,9 @@ public:
     void VRDPInterceptUSB(uint32_t u32ClientId, void **ppvIntercept);
     void VRDPInterceptClipboard(uint32_t u32ClientId);
 
+#if 0
     void processRemoteUSBDevices(uint32_t u32ClientId, VRDEUSBDEVICEDESC *pDevList, uint32_t cbDevList, bool fDescExt);
+#endif /* if 0 */
     void reportVmStatistics(ULONG aValidStats, ULONG aCpuUser,
                                ULONG aCpuKernel, ULONG aCpuIdle,
                                ULONG aMemTotal, ULONG aMemFree,
@@ -261,10 +265,12 @@ public:
                                ULONG aBalloonedVMM, ULONG aSharedVMM,
                                ULONG aVmNetRx, ULONG aVmNetTx)
     {
+#if 0
         mControl->ReportVmStatistics(aValidStats, aCpuUser, aCpuKernel, aCpuIdle,
                                      aMemTotal, aMemFree, aMemBalloon, aMemShared,
                                      aMemCache, aPageTotal, aAllocVMM, aFreeVMM,
                                      aBalloonedVMM, aSharedVMM, aVmNetRx, aVmNetTx);
+#endif /* if 0 */
     }
     void enableVMMStatistics(BOOL aEnable);
 
@@ -274,12 +280,12 @@ public:
 
     // callback callers (partly; for some events console callbacks are notified
     // directly from IInternalSessionControl event handlers declared above)
-    void onMousePointerShapeChange(bool fVisible, bool fAlpha,
-                                   uint32_t xHot, uint32_t yHot,
-                                   uint32_t width, uint32_t height,
-                                   ComSafeArrayIn(uint8_t, aShape));
-    void onMouseCapabilityChange(BOOL supportsAbsolute, BOOL supportsRelative,
-                                 BOOL supportsMT, BOOL needsHostCursor);
+    virtual void onMousePointerShapeChange(bool fVisible, bool fAlpha,
+                                           uint32_t xHot, uint32_t yHot,
+                                           uint32_t width, uint32_t height,
+                                           ComSafeArrayIn(uint8_t, aShape)) = 0;
+    virtual void onMouseCapabilityChange(BOOL supportsAbsolute, BOOL supportsRelative,
+                                         BOOL supportsMT, BOOL needsHostCursor) = 0;
     void onStateChange(MachineState_T aMachineState);
     void onAdditionsStateChange();
     void onAdditionsOutdated();
diff --git a/src/app/virtualbox/src/VBox/Main/include/DisplayImpl.h b/src/app/virtualbox/src/VBox/Main/include/DisplayImpl.h
index 585f6b2..ecb58b9 100644
--- a/src/app/virtualbox/src/VBox/Main/include/DisplayImpl.h
+++ b/src/app/virtualbox/src/VBox/Main/include/DisplayImpl.h
@@ -122,7 +122,7 @@ typedef struct _DISPLAYFBINFO
 class DisplayMouseInterface
 {
 public:
-    virtual int getScreenResolution(uint32_t cScreen, ULONG *pcx,
+    virtual HRESULT getScreenResolution(uint32_t cScreen, ULONG *pcx,
                                     ULONG *pcy, ULONG *pcBPP, LONG *pXOrigin, LONG *pYOrigin) = 0;
     virtual void getFramebufferDimensions(int32_t *px1, int32_t *py1,
                                           int32_t *px2, int32_t *py2) = 0;
@@ -192,7 +192,7 @@ public:
         return maFramebuffers[VBOX_VIDEO_PRIMARY_SCREEN].pFramebuffer;
     }
     void getFramebufferDimensions(int32_t *px1, int32_t *py1, int32_t *px2, int32_t *py2);
-    int getScreenResolution(uint32_t cScreen, ULONG *pcx, ULONG *pcy,
+    HRESULT getScreenResolution(uint32_t cScreen, ULONG *pcx, ULONG *pcy,
                             ULONG *pcBPP, LONG *pXOrigin, LONG *pYOrigin)
     {
         return GetScreenResolution(cScreen, pcx, pcy, pcBPP, pXOrigin, pYOrigin);
@@ -232,6 +232,10 @@ public:
 
     static const PDMDRVREG  DrvReg;
 
+#if 0
+    static void fireGuestMonitorChangedEvent(EventSource*, GuestMonitorChangedEventType, int32_t, int32_t, int32_t, int32_t, int32_t);
+#endif
+
 private:
 
     int updateDisplayData(void);
diff --git a/src/app/virtualbox/src/VBox/Main/include/FramebufferImpl.h b/src/app/virtualbox/src/VBox/Main/include/FramebufferImpl.h
index feebfcd..4136d6d 100644
--- a/src/app/virtualbox/src/VBox/Main/include/FramebufferImpl.h
+++ b/src/app/virtualbox/src/VBox/Main/include/FramebufferImpl.h
@@ -70,6 +70,7 @@ public:
     STDMETHOD(SetVisibleRegion)(BYTE *aRectangles, ULONG aCount) = 0;
 
     STDMETHOD(ProcessVHWACommand)(BYTE *pCommand) = 0;
+    STDMETHOD(NotifyUpdate)(ULONG x, ULONG y, ULONG w, ULONG h) = 0;
 };
 
 #endif // ____H_H_FRAMEBUFFERIMPL
diff --git a/src/app/virtualbox/src/VBox/Main/include/NetworkServiceRunner.h b/src/app/virtualbox/src/VBox/Main/include/NetworkServiceRunner.h
index f0ec275..78a390e 100644
--- a/src/app/virtualbox/src/VBox/Main/include/NetworkServiceRunner.h
+++ b/src/app/virtualbox/src/VBox/Main/include/NetworkServiceRunner.h
@@ -15,6 +15,9 @@
  * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
  */
 
+#ifndef ____H_H_NetworkServiceRunner
+#define ____H_H_NetworkServiceRunner
+
 #include <iprt/err.h>
 #include <iprt/types.h>
 #include <iprt/string.h>
@@ -55,3 +58,5 @@ private:
     struct Data;
     Data *m;
 };
+
+#endif /* ____H_H_NetworkServiceRunner */
diff --git a/src/app/virtualbox/src/VBox/Main/include/ProgressProxyImpl.h b/src/app/virtualbox/src/VBox/Main/include/ProgressProxyImpl.h
index 66f2b31..0ac7ab8 100644
--- a/src/app/virtualbox/src/VBox/Main/include/ProgressProxyImpl.h
+++ b/src/app/virtualbox/src/VBox/Main/include/ProgressProxyImpl.h
@@ -52,7 +52,7 @@ public:
 #if !defined (VBOX_COM_INPROC)
                  VirtualBox *pParent,
 #endif
-                 IUnknown *pInitiator,
+                 void *pInitiator,
                  CBSTR bstrDescription,
                  BOOL fCancelable,
                  ULONG uTotalOperationsWeight,
diff --git a/src/app/virtualbox/src/VBox/Main/include/SessionImpl.h b/src/app/virtualbox/src/VBox/Main/include/SessionImpl.h
index b0f600e..bcd6b4c 100644
--- a/src/app/virtualbox/src/VBox/Main/include/SessionImpl.h
+++ b/src/app/virtualbox/src/VBox/Main/include/SessionImpl.h
@@ -24,6 +24,8 @@
 # include "win/resource.h"
 #endif
 
+class GenodeConsole;
+
 #ifdef RT_OS_WINDOWS
 [threading(free)]
 #endif
@@ -122,7 +124,7 @@ private:
     ComPtr<IInternalMachineControl> mControl;
 
 #ifndef VBOX_COM_INPROC_API_CLIENT
-    ComObjPtr<Console> mConsole;
+    ComObjPtr<GenodeConsole> mConsole;
 #endif
 
     ComPtr<IMachine> mRemoteMachine;
diff --git a/src/app/virtualbox/src/VBox/Main/src-all/EventImpl.cpp b/src/app/virtualbox/src/VBox/Main/src-all/EventImpl.cpp
index 182f267..90b8716 100644
--- a/src/app/virtualbox/src/VBox/Main/src-all/EventImpl.cpp
+++ b/src/app/virtualbox/src/VBox/Main/src-all/EventImpl.cpp
@@ -1263,7 +1263,8 @@ STDMETHODIMP EventSource::EventProcessed(IEventListener *aListener,
  */
 class ATL_NO_VTABLE PassiveEventListener :
     public VirtualBoxBase,
-    VBOX_SCRIPTABLE_IMPL(IEventListener)
+    public IEventListener
+//    VBOX_SCRIPTABLE_IMPL(IEventListener)
 {
 public:
 
@@ -1302,7 +1303,8 @@ public:
 /* Proxy listener class, used to aggregate multiple event sources into one */
 class ATL_NO_VTABLE ProxyEventListener :
     public VirtualBoxBase,
-    VBOX_SCRIPTABLE_IMPL(IEventListener)
+    public IEventListener
+//    VBOX_SCRIPTABLE_IMPL(IEventListener)
 {
     ComPtr<IEventSource> mSource;
 public:
@@ -1349,8 +1351,9 @@ public:
 };
 
 class ATL_NO_VTABLE EventSourceAggregator :
-    public VirtualBoxBase,
-    VBOX_SCRIPTABLE_IMPL(IEventSource)
+//    public VirtualBoxBase,
+    public EventSource
+//    VBOX_SCRIPTABLE_IMPL(IEventSource)
 {
     typedef std::list <ComPtr<IEventSource> > EventSourceList;
     /* key is weak reference */
@@ -1417,6 +1420,7 @@ public:
     HRESULT removeProxyListener(IEventListener *aListener);
 };
 
+#if 0
 #ifdef VBOX_WITH_XPCOM
 NS_DECL_CLASSINFO(ProxyEventListener)
 NS_IMPL_THREADSAFE_ISUPPORTS1_CI(ProxyEventListener, IEventListener)
@@ -1431,6 +1435,7 @@ NS_IMPL_THREADSAFE_ISUPPORTS1_CI(EventSource, IEventSource)
 NS_DECL_CLASSINFO(EventSourceAggregator)
 NS_IMPL_THREADSAFE_ISUPPORTS1_CI(EventSourceAggregator, IEventSource)
 #endif
+#endif
 
 
 STDMETHODIMP EventSource::CreateListener(IEventListener **aListener)
diff --git a/src/app/virtualbox/src/VBox/Main/src-all/PCIDeviceAttachmentImpl.cpp b/src/app/virtualbox/src/VBox/Main/src-all/PCIDeviceAttachmentImpl.cpp
index e984238..b02cb45 100644
--- a/src/app/virtualbox/src/VBox/Main/src-all/PCIDeviceAttachmentImpl.cpp
+++ b/src/app/virtualbox/src/VBox/Main/src-all/PCIDeviceAttachmentImpl.cpp
@@ -131,6 +131,6 @@ STDMETHODIMP PCIDeviceAttachment::COMGETTER(GuestAddress)(LONG * aGuestAddress)
 }
 
 #ifdef VBOX_WITH_XPCOM
-NS_DECL_CLASSINFO(PCIDeviceAttachment)
-NS_IMPL_THREADSAFE_ISUPPORTS1_CI(PCIDeviceAttachment, IPCIDeviceAttachment)
+//NS_DECL_CLASSINFO(PCIDeviceAttachment)
+//NS_IMPL_THREADSAFE_ISUPPORTS1_CI(PCIDeviceAttachment, IPCIDeviceAttachment)
 #endif
diff --git a/src/app/virtualbox/src/VBox/Main/src-all/ProgressImpl.cpp b/src/app/virtualbox/src/VBox/Main/src-all/ProgressImpl.cpp
index fa3ecea..ac1a203 100644
--- a/src/app/virtualbox/src/VBox/Main/src-all/ProgressImpl.cpp
+++ b/src/app/virtualbox/src/VBox/Main/src-all/ProgressImpl.cpp
@@ -20,9 +20,9 @@
 
 
 #if defined(VBOX_WITH_XPCOM)
-#include <nsIServiceManager.h>
-#include <nsIExceptionService.h>
-#include <nsCOMPtr.h>
+//#include <nsIServiceManager.h>
+//#include <nsIExceptionService.h>
+//#include <nsCOMPtr.h>
 #endif /* defined(VBOX_WITH_XPCOM) */
 
 #include "ProgressImpl.h"
@@ -98,7 +98,7 @@ STDMETHODIMP Progress::COMGETTER(Initiator)(IUnknown **aInitiator)
     else
     {
         ComObjPtr<VirtualBox> pVirtualBox(mParent);
-        pVirtualBox.queryInterfaceTo(aInitiator);
+//        pVirtualBox.queryInterfaceTo(aInitiator);
     }
 #else
     mInitiator.queryInterfaceTo(aInitiator);
@@ -573,8 +573,10 @@ HRESULT Progress::init(
 #endif
 
     unconst(mId).create();
+/*
     if (aId)
         mId.cloneTo(aId);
+*/
 
 #if !defined(VBOX_COM_INPROC)
     /* add to the global collection of progress operations (note: after
@@ -1057,7 +1059,7 @@ HRESULT Progress::setResultCode(HRESULT aResultCode)
         }
 
 #else /* !defined(VBOX_WITH_XPCOM) */
-
+/*
         nsCOMPtr<nsIExceptionService> es;
         es = do_GetService(NS_EXCEPTIONSERVICE_CONTRACTID, &rc);
         if (NS_SUCCEEDED(rc))
@@ -1076,6 +1078,7 @@ HRESULT Progress::setResultCode(HRESULT aResultCode)
                 }
             }
         }
+*/
 #endif /* !defined(VBOX_WITH_XPCOM) */
 
         AssertMsg(rc == S_OK, ("Couldn't get error info (rc=%08X) while trying to set a failed result (%08X)!\n",
diff --git a/src/app/virtualbox/src/VBox/Main/src-all/VirtualBoxBase.cpp b/src/app/virtualbox/src/VBox/Main/src-all/VirtualBoxBase.cpp
index b43f5a6..6aef9df 100644
--- a/src/app/virtualbox/src/VBox/Main/src-all/VirtualBoxBase.cpp
+++ b/src/app/virtualbox/src/VBox/Main/src-all/VirtualBoxBase.cpp
@@ -23,6 +23,7 @@
 
 #include <typeinfo>
 
+#if 0
 #if !defined (VBOX_WITH_XPCOM)
 #include <windows.h>
 #include <dbghelp.h>
@@ -31,6 +32,7 @@
 #include <nsIServiceManager.h>
 #include <nsIExceptionService.h>
 #endif /* !defined (VBOX_WITH_XPCOM) */
+#endif
 
 #include "VirtualBoxBase.h"
 #include "AutoCaller.h"
@@ -296,6 +298,7 @@ void VirtualBoxBase::releaseCaller()
     AssertMsgFailed (("mState = %d!", mState));
 }
 
+#if 0
 /**
  * Handles unexpected exceptions by turning them into COM errors in release
  * builds or by hitting a breakpoint in the release builds.
@@ -770,6 +773,7 @@ void VirtualBoxBase::clearError(void)
 #endif
 }
 
+#endif /* if 0 */
 
 ////////////////////////////////////////////////////////////////////////////////
 //
diff --git a/src/app/virtualbox/src/VBox/Main/src-client/BusAssignmentManager.cpp b/src/app/virtualbox/src/VBox/Main/src-client/BusAssignmentManager.cpp
index 068bb79..3b6adb3 100644
--- a/src/app/virtualbox/src/VBox/Main/src-client/BusAssignmentManager.cpp
+++ b/src/app/virtualbox/src/VBox/Main/src-client/BusAssignmentManager.cpp
@@ -72,6 +72,8 @@ static const DeviceAssignmentRule aGenericRules[] =
     {"usb-ohci",      0,  6,  0, 0},
     {"usb-ehci",      0, 11,  0, 0},
 
+    {"nec-xhci",      0, 29,  0, 0},
+
     /* ACPI controller */
     {"acpi",          0,  7,  0, 0},
 
diff --git a/src/app/virtualbox/src/VBox/Main/src-client/ConsoleImpl.cpp b/src/app/virtualbox/src/VBox/Main/src-client/ConsoleImpl.cpp
index 69e3109..3c534df 100644
--- a/src/app/virtualbox/src/VBox/Main/src-client/ConsoleImpl.cpp
+++ b/src/app/virtualbox/src/VBox/Main/src-client/ConsoleImpl.cpp
@@ -51,23 +51,32 @@
 #include "KeyboardImpl.h"
 #include "MouseImpl.h"
 #include "DisplayImpl.h"
+#if 0
 #include "MachineDebuggerImpl.h"
 #include "USBDeviceImpl.h"
 #include "RemoteUSBDeviceImpl.h"
+#endif
 #include "SharedFolderImpl.h"
+#if 0
 #include "AudioSnifferInterface.h"
 #include "Nvram.h"
 #ifdef VBOX_WITH_USB_CARDREADER
 # include "UsbCardReader.h"
 #endif
+#endif
 #include "ProgressImpl.h"
+#if 0
 #include "ConsoleVRDPServer.h"
+#endif
 #include "VMMDev.h"
+#if 0
 #ifdef VBOX_WITH_EXTPACK
 # include "ExtPackManagerImpl.h"
 #endif
 #include "BusAssignmentManager.h"
 #include "EmulatedUSBImpl.h"
+#endif
+#include "VirtualBoxImpl.h"
 
 #include "VBoxEvents.h"
 #include "AutoCaller.h"
@@ -75,7 +84,9 @@
 
 #include <VBox/com/array.h>
 #include "VBox/com/ErrorInfo.h"
+#if 0
 #include <VBox/com/listeners.h>
+#endif
 
 #include <iprt/asm.h>
 #include <iprt/buildconfig.h>
@@ -90,9 +101,12 @@
 #include <iprt/base64.h>
 #include <iprt/memsafer.h>
 
+#if 0
 #include <VBox/vmm/vmapi.h>
 #include <VBox/vmm/vmm.h>
+#endif
 #include <VBox/vmm/pdmapi.h>
+#if 0
 #include <VBox/vmm/pdmasynccompletion.h>
 #include <VBox/vmm/pdmnetifs.h>
 #ifdef VBOX_WITH_USB
@@ -109,14 +123,17 @@
 #include <VBox/vusb.h>
 
 #include <VBox/VMMDev.h>
-
+#endif
 #include <VBox/HostServices/VBoxClipboardSvc.h>
+#if 0
 #include <VBox/HostServices/DragAndDropSvc.h>
 #ifdef VBOX_WITH_GUEST_PROPS
 # include <VBox/HostServices/GuestPropertySvc.h>
 # include <VBox/com/array.h>
 #endif
 
+#endif /* #if 0 */
+
 #include <set>
 #include <algorithm>
 #include <memory> // for auto_ptr
@@ -278,6 +295,8 @@ struct VMSaveTask : public VMTask
     Reason_T mReason;
 };
 
+#if 0
+
 // Handler for global events
 ////////////////////////////////////////////////////////////////////////////////
 inline static const char *networkAdapterTypeToName(NetworkAdapterType_T adapterType);
@@ -383,6 +402,7 @@ typedef ListenerImpl<VmEventListener, Console*> VmEventListenerImpl;
 
 VBOX_LISTENER_DECLARE(VmEventListenerImpl)
 
+#endif /* #if 0 */
 
 // constructor / destructor
 /////////////////////////////////////////////////////////////////////////////
@@ -530,6 +550,7 @@ HRESULT Console::init(IMachine *aMachine, IInternalMachineControl *aControl, Loc
         rc = mDisplay->init(this);
         AssertComRCReturnRC(rc);
 
+#if 0
         unconst(mVRDEServerInfo).createObject();
         rc = mVRDEServerInfo->init(this);
         AssertComRCReturnRC(rc);
@@ -538,6 +559,7 @@ HRESULT Console::init(IMachine *aMachine, IInternalMachineControl *aControl, Loc
         rc = mEmulatedUSB->init(this);
         AssertComRCReturnRC(rc);
 
+#endif
         /* Grab global and machine shared folder lists */
 
         rc = fetchSharedFolders(true /* aGlobal */);
@@ -545,10 +567,12 @@ HRESULT Console::init(IMachine *aMachine, IInternalMachineControl *aControl, Loc
         rc = fetchSharedFolders(false /* aGlobal */);
         AssertComRCReturnRC(rc);
 
+#if 0
         /* Create other child objects */
 
         unconst(mConsoleVRDPServer) = new ConsoleVRDPServer(this);
         AssertReturn(mConsoleVRDPServer, E_FAIL);
+#endif
 
         /* Figure out size of meAttachmentType vector */
         ComPtr<IVirtualBox> pVirtualBox;
@@ -574,9 +598,11 @@ HRESULT Console::init(IMachine *aMachine, IInternalMachineControl *aControl, Loc
         //     unconst(m_pVMMDev) = new VMMDev(this);
         //     AssertReturn(mVMMDev, E_FAIL);
 
+#if 0
         unconst(mAudioSniffer) = new AudioSniffer(this);
         AssertReturn(mAudioSniffer, E_FAIL);
 
+#endif
         FirmwareType_T enmFirmwareType;
         mMachine->COMGETTER(FirmwareType)(&enmFirmwareType);
         if (   enmFirmwareType == FirmwareType_EFI
@@ -584,8 +610,10 @@ HRESULT Console::init(IMachine *aMachine, IInternalMachineControl *aControl, Loc
             || enmFirmwareType == FirmwareType_EFI64
             || enmFirmwareType == FirmwareType_EFIDUAL)
         {
+#if 0
             unconst(mNvram) = new Nvram(this);
             AssertReturn(mNvram, E_FAIL);
+#endif
         }
 
 #ifdef VBOX_WITH_USB_CARDREADER
@@ -593,6 +621,7 @@ HRESULT Console::init(IMachine *aMachine, IInternalMachineControl *aControl, Loc
         AssertReturn(mUsbCardReader, E_FAIL);
 #endif
 
+#if 0
         /* VirtualBox events registration. */
         {
             ComPtr<IEventSource> pES;
@@ -609,6 +638,7 @@ HRESULT Console::init(IMachine *aMachine, IInternalMachineControl *aControl, Loc
             rc = pES->RegisterListener(aVmListener, ComSafeArrayAsInParam(eventTypes), true);
             AssertComRC(rc);
         }
+#endif
     }
 
     /* Confirm a successful initialization when it's the case */
@@ -625,6 +655,7 @@ HRESULT Console::init(IMachine *aMachine, IInternalMachineControl *aControl, Loc
     return S_OK;
 }
 
+#if 0
 /**
  * Uninitializes the Console object.
  */
@@ -817,6 +848,8 @@
     LogFlowThisFuncLeave();
 }
 
+#endif /* #if 0 */
+
 #ifdef VBOX_WITH_GUEST_PROPS
 
 /**
@@ -858,6 +891,8 @@
         LogRel(("RESET: Unable to enumerate guest properties, rc=%Rhrc\n", hrc));
 }
 
+#if 0
+
 bool Console::guestPropertiesVRDPEnabled(void)
 {
     Bstr value;
@@ -1055,6 +1090,8 @@
     return;
 }
 
+#endif /* #if 0 */
+
 #endif /* VBOX_WITH_GUEST_PROPS */
 
 bool Console::isResetTurnedIntoPowerOff(void)
@@ -1046,6 +1079,8 @@ bool Console::isResetTurnedIntoPowerOff(void)
     return false;
 }
 
+#if 0
+
 #ifdef VBOX_WITH_EXTPACK
 /**
  * Used by VRDEServer and others to talke to the extension pack manager.
@@ -1505,6 +1540,7 @@ void Console::VRDPInterceptClipboard(uint32_t u32ClientId)
     return;
 }
 
+#endif /* if 0 */
 
 //static
 const char *Console::sSSMConsoleUnit = "ConsoleData";
@@ -1970,6 +2006,8 @@ STDMETHODIMP Console::COMGETTER(Display)(IDisplay **aDisplay)
     return S_OK;
 }
 
+#if 0
+
 STDMETHODIMP Console::COMGETTER(Debugger)(IMachineDebugger **aDebugger)
 {
     CheckComArgOutPointerValid(aDebugger);
@@ -2069,6 +2107,7 @@ Console::COMGETTER(SharedFolders)(ComSafeArrayOut(ISharedFolder *, aSharedFolder
     return S_OK;
 }
 
+#endif /* #if 0 */
 
 STDMETHODIMP Console::COMGETTER(EventSource)(IEventSource ** aEventSource)
 {
@@ -2085,6 +2124,8 @@ STDMETHODIMP Console::COMGETTER(EventSource)(IEventSource ** aEventSource)
     return hrc;
 }
 
+#if 0
+
 STDMETHODIMP Console::COMGETTER(AttachedPCIDevices)(ComSafeArrayOut(IPCIDeviceAttachment *, aAttachments))
 {
     CheckComArgOutSafeArrayPointerValid(aAttachments);
@@ -2134,6 +2175,7 @@ STDMETHODIMP Console::COMSETTER(UseHostClipboard)(BOOL aUseHostClipboard)
 // IConsole methods
 /////////////////////////////////////////////////////////////////////////////
 
+#endif /* #if 0 */
 
 STDMETHODIMP Console::PowerUp(IProgress **aProgress)
 {
@@ -2291,6 +2333,8 @@ STDMETHODIMP Console::PowerDown(IProgress **aProgress)
     return rc;
 }
 
+#if 0
+ 
 STDMETHODIMP Console::Reset()
 {
     LogFlowThisFuncEnter();
@@ -2579,6 +2623,7 @@ STDMETHODIMP Console::Resume()
     LogFlowThisFuncLeave();
     return rc;
 }
+#endif
 
 STDMETHODIMP Console::PowerButton()
 {
@@ -2625,6 +2670,7 @@ STDMETHODIMP Console::PowerButton()
     return rc;
 }
 
+#if 0
 STDMETHODIMP Console::GetPowerButtonHandled(BOOL *aHandled)
 {
     LogFlowThisFuncEnter();
@@ -3451,6 +3497,8 @@ STDMETHODIMP Console::RestoreSnapshot(ISnapshot *aSnapshot, IProgress **aProgres
     return S_OK;
 }
 
+#endif /* #if 0 */
+
 // Non-interface public methods
 /////////////////////////////////////////////////////////////////////////////
 
@@ -3526,6 +3574,8 @@ HRESULT Console::convertBusPortDeviceToLun(StorageBus_T enmBus, LONG port, LONG
     }
 }
 
+#if 0
+
 // private methods
 /////////////////////////////////////////////////////////////////////////////
     
@@ -4388,6 +4438,8 @@ HRESULT Console::onNATRedirectRuleChange(ULONG ulInstance, BOOL aNatRuleRemove,
     return rc;
 }
 
+#endif /* #if 0 */
+
 VMMDevMouseInterface *Console::getVMMDevMouseInterface()
 {
     return m_pVMMDev;
@@ -4398,6 +4450,8 @@ DisplayMouseInterface *Console::getDisplayMouseInterface()
     return mDisplay;
 }
 
+#if 0
+
 /**
  * Parses one key value pair.
  *
@@ -4566,6 +4620,8 @@
     return rc;
 }
 
+#endif /* #if 0 */
+
 /**
  * Removes the key interfaces from all disk attachments, useful when
  * changing the key store or dropping it.
@@ -4650,6 +4706,8 @@
     return hrc;
 }
 
+#if 0
+
 /**
  * Configures the encryption support for the disk identified by the gien UUID with
  * the given key.
@@ -5344,6 +5402,8 @@
     fireVRDEServerInfoChangedEvent(mEventSource);
 }
 
+#endif /* #if 0 */
+
 HRESULT Console::i_sendACPIMonitorHotPlugEvent()
 {
     LogFlowThisFuncEnter();
@@ -5385,6 +5445,8 @@
     return rc;
 }
 
+#if 0
+
 HRESULT Console::onVideoCaptureChange()
 {
     AutoCaller autoCaller(this);
@@ -5778,6 +5844,8 @@
     return hrc;
 }
 
+#endif /* #if 0 */
+
 /**
  * @note Temporarily locks this object for writing.
  */
@@ -5978,6 +6046,7 @@
 #endif /* VBOX_WITH_GUEST_PROPS */
 }
 
+#if 0
 
 /*
  * Internal: helper function for connecting progress reporting
@@ -6490,6 +6544,8 @@ void Console::onMouseCapabilityChange(BOOL supportsAbsolute, BOOL supportsRelati
     fireMouseCapabilityChangedEvent(mEventSource, supportsAbsolute, supportsRelative, supportsMT, needsHostCursor);
 }
 
+#endif /* #if 0 */
+
 void Console::onStateChange(MachineState_T machineState)
 {
     AutoCaller autoCaller(this);
@@ -6497,6 +6553,8 @@ void Console::onStateChange(MachineState_T machineState)
     fireStateChangedEvent(mEventSource, machineState);
 }
 
+#if 0
+
 void Console::onAdditionsStateChange()
 {
     AutoCaller autoCaller(this);
@@ -6555,6 +6613,8 @@ void Console::onUSBDeviceStateChange(IUSBDevice *aDevice, bool aAttached,
     fireUSBDeviceStateChangedEvent(mEventSource, aDevice, aAttached, aError);
 }
 
+#endif /* #if 0 */
+
 void Console::onRuntimeError(BOOL aFatal, IN_BSTR aErrorID, IN_BSTR aMessage)
 {
     AutoCaller autoCaller(this);
@@ -6563,6 +6623,8 @@ void Console::onRuntimeError(BOOL aFatal, IN_BSTR aErrorID, IN_BSTR aMessage)
     fireRuntimeErrorEvent(mEventSource, aFatal, aErrorID, aMessage);
 }
 
+#if 0
+
 HRESULT Console::onShowWindow(BOOL aCheck, BOOL *aCanShow, LONG64 *aWinId)
 {
     AssertReturn(aCanShow, E_POINTER);
@@ -6626,6 +6688,8 @@ HRESULT Console::onShowWindow(BOOL aCheck, BOOL *aCanShow, LONG64 *aWinId)
     return S_OK;
 }
 
+#endif /* #if 0 */
+
 // private methods
 ////////////////////////////////////////////////////////////////////////////////
 
@@ -6819,6 +6883,8 @@ HRESULT Console::consoleInitReleaseLog(const ComPtr<IMachine> aMachine)
         }
     }
 
+#if 0
+
     char szError[RTPATH_MAX + 128];
     int vrc = com::VBoxLogRelCreate("VM", logFile.c_str(),
                                     RTLOGFLAGS_PREFIX_TIME_PROG | RTLOGFLAGS_RESTRICT_GROUPS,
@@ -6839,6 +6905,8 @@ HRESULT Console::consoleInitReleaseLog(const ComPtr<IMachine> aMachine)
     if (SUCCEEDED(hrc) || cHistoryFiles)
         RTDirFlush(logDir.c_str());
 
+#endif /* if 0 */
+
     return hrc;
 }
 
@@ -7113,6 +7181,10 @@ HRESULT Console::powerUp(IProgress **aProgress, bool aPaused)
         }
 #endif
 
+        ComPtr<IVirtualBox> pIVirtualBox;
+        mMachine->COMGETTER(Parent)(pIVirtualBox.asOutParam());
+		VirtualBox *pVirtualBox =
+			dynamic_cast<VirtualBox*>(*pIVirtualBox.asOutParam());
 
         // If there is immutable drive the process that.
         VMPowerUpTask::ProgressList progresses(task->hardDiskProgresses);
@@ -7123,7 +7195,8 @@ HRESULT Console::powerUp(IProgress **aProgress, bool aPaused)
                 ++cOperations;
                 ulTotalOperationsWeight += 1;
             }
-            rc = pPowerupProgress->init(static_cast<IConsole *>(this),
+            rc = pPowerupProgress->init(pVirtualBox,
+                                        static_cast<IConsole *>(this),
                                         progressDesc.raw(),
                                         TRUE, // Cancelable
                                         cOperations,
@@ -7136,13 +7209,15 @@ HRESULT Console::powerUp(IProgress **aProgress, bool aPaused)
         else if (    mMachineState == MachineState_Saved
             ||  (!fTeleporterEnabled && !fFaultToleranceSyncEnabled))
         {
-            rc = pPowerupProgress->init(static_cast<IConsole *>(this),
+            rc = pPowerupProgress->init(pVirtualBox,
+                                        static_cast<IConsole *>(this),
                                         progressDesc.raw(),
                                         FALSE /* aCancelable */);
         }
         else if (fTeleporterEnabled)
         {
-            rc = pPowerupProgress->init(static_cast<IConsole *>(this),
+            rc = pPowerupProgress->init(pVirtualBox,
+                                        static_cast<IConsole *>(this),
                                         progressDesc.raw(),
                                         TRUE /* aCancelable */,
                                         3    /* cOperations */,
@@ -7153,7 +7228,8 @@ HRESULT Console::powerUp(IProgress **aProgress, bool aPaused)
         }
         else if (fFaultToleranceSyncEnabled)
         {
-            rc = pPowerupProgress->init(static_cast<IConsole *>(this),
+            rc = pPowerupProgress->init(pVirtualBox,
+                                        static_cast<IConsole *>(this),
                                         progressDesc.raw(),
                                         TRUE /* aCancelable */,
                                         3    /* cOperations */,
@@ -7399,6 +7475,7 @@ HRESULT Console::powerDown(IProgress *aProgress /*= NULL*/)
      * safe to release the object lock now if needed)
      * ---------------------------------------------------------------------- */
 
+#if 0
     /* Stop the VRDP server to prevent new clients connection while VM is being
      * powered off. */
     if (mConsoleVRDPServer)
@@ -7413,6 +7490,7 @@ HRESULT Console::powerDown(IProgress *aProgress /*= NULL*/)
 
         alock.acquire();
     }
+#endif
 
     /* advance percent count */
     if (aProgress)
@@ -7649,6 +7727,8 @@ HRESULT Console::setMachineState(MachineState_T aMachineState,
     return rc;
 }
 
+#if 0
+
 /**
  * Searches for a shared folder with the given logical name
  * in the collection of shared folders.
@@ -7684,6 +7764,8 @@ HRESULT Console::findSharedFolder(const Utf8Str &strName,
     return VBOX_E_FILE_ERROR;
 }
 
+#endif /* #if 0 */
+
 /**
  * Fetches the list of global or machine shared folders from the server.
  *
@@ -8390,6 +8472,8 @@ void Console::changeClipboardMode(ClipboardMode_T aClipboardMode)
     pVMMDev->hgcmHostCall("VBoxSharedClipboard", VBOX_SHARED_CLIPBOARD_HOST_FN_SET_MODE, 1, &parm);
 }
 
+#if 0
+
 /**
  * Changes the drag'n_drop mode.
  *
@@ -8590,12 +8674,13 @@ HRESULT Console::detachUSBDevice(const ComObjPtr<OUSBDevice> &aHostDevice)
         setErrorStatic(hrc2, "GetRemote() failed");
 
     PCRTUUID pUuid = aHostDevice->id().raw();
+#if 0
     if (fRemote)
     {
         Guid guid(*pUuid);
         consoleVRDPServer()->USBBackendReleasePointer(&guid);
     }
-
+#endif
     alock.release();
     int vrc = VMR3ReqCallWaitU(ptrVM.rawUVM(), 0 /* idDstCpu (saved state, see #6232) */,
                                (PFNRT)usbDetachCallback, 5,
@@ -8875,6 +8960,8 @@ HRESULT Console::detachFromTapInterface(INetworkAdapter *networkAdapter)
 }
 #endif /* (RT_OS_LINUX || RT_OS_FREEBSD) && !VBOX_WITH_NETFLT */
 
+#endif /* #if 0 */
+
 /**
  * Called at power down to terminate host interface networking.
  *
@@ -9077,6 +9164,8 @@ void Console::detachAllUSBDevices(bool aDone)
     mControl->DetachAllUSBDevices(aDone);
 }
 
+#if 0
+
 /**
  * @note Locks this object for writing.
  */
@@ -9249,6 +9338,8 @@ void Console::processRemoteUSBDevices(uint32_t u32ClientId, VRDEUSBDEVICEDESC *p
     LogFlowThisFuncLeave();
 }
 
+#endif /* #if 0 */
+
 /**
  * Progress cancelation callback for fault tolerance VM poweron
  */
@@ -9346,6 +9437,7 @@ DECLCALLBACK(int) Console::powerUpThread(RTTHREAD Thread, void *pvUser)
         /* Create the VRDP server. In case of headless operation, this will
          * also create the framebuffer, required at VM creation.
          */
+#if 0
         ConsoleVRDPServer *server = pConsole->consoleVRDPServer();
         Assert(server);
 
@@ -9392,6 +9484,7 @@ DECLCALLBACK(int) Console::powerUpThread(RTTHREAD Thread, void *pvUser)
                      vrc, errMsg.c_str()));
             throw setErrorStatic(E_FAIL, errMsg.c_str());
         }
+#endif
 
         ComPtr<IMachine> pMachine = pConsole->machine();
         ULONG cCpus = 1;
@@ -9416,8 +9509,10 @@ DECLCALLBACK(int) Console::powerUpThread(RTTHREAD Thread, void *pvUser)
 
         alock.acquire();
 
+#if 0
         /* Enable client connections to the server. */
         pConsole->consoleVRDPServer()->EnableConnections();
+#endif
 
         if (RT_SUCCESS(vrc))
         {
@@ -9441,9 +9536,11 @@ DECLCALLBACK(int) Console::powerUpThread(RTTHREAD Thread, void *pvUser)
                 /*
                  * Synchronize debugger settings
                  */
+#if 0
                 MachineDebugger *machineDebugger = pConsole->getMachineDebugger();
                 if (machineDebugger)
                     machineDebugger->flushQueuedSettings();
+#endif
 
                 /*
                  * Shared Folders
@@ -9719,6 +9816,7 @@ DECLCALLBACK(int) Console::powerUpThread(RTTHREAD Thread, void *pvUser)
     return VINF_SUCCESS;
 }
 
+#if 0
 
 /**
  * Reconfigures a medium attachment (part of taking or deleting an online snapshot).
@@ -10209,6 +10307,8 @@ DECLCALLBACK(int) Console::saveStateThread(RTTHREAD Thread, void *pvUser)
     return VINF_SUCCESS;
 }
 
+#endif /* #if 0 */
+
 /**
  * Thread for powering down the Console.
  *
diff --git a/src/app/virtualbox/src/VBox/Main/src-client/ConsoleImpl2.cpp b/src/app/virtualbox/src/VBox/Main/src-client/ConsoleImpl2.cpp
index caed4be..19c3dc0 100644
--- a/src/app/virtualbox/src/VBox/Main/src-client/ConsoleImpl2.cpp
+++ b/src/app/virtualbox/src/VBox/Main/src-client/ConsoleImpl2.cpp
@@ -27,6 +27,7 @@
 #include "VBox/com/ptr.h"
 
 #include "ConsoleImpl.h"
+#include "MachineImpl.h"
 #include "DisplayImpl.h"
 #ifdef VBOX_WITH_GUEST_CONTROL
 # include "GuestImpl.h"
@@ -129,6 +130,7 @@
 *******************************************************************************/
 static Utf8Str *GetExtraDataBoth(IVirtualBox *pVirtualBox, IMachine *pMachine, const char *pszName, Utf8Str *pStrValue);
 
+#if 0
 
 
 #if defined(RT_OS_DARWIN)
@@ -202,6 +204,7 @@ static int DarwinSmcKey(char *pabKey, uint32_t cbKey)
 /* Comment out the following line to remove VMWare compatibility hack. */
 #define VMWARE_NET_IN_SLOT_11
 
+#endif
 /**
  * Translate IDE StorageControllerType_T to string representation.
  */
@@ -602,6 +602,7 @@ static int SetBiosDiskInfo(ComPtr<IMachine> pMachine, PCFGMNODE pCfg, PCFGMNODE
     return S_OK;
 }
 
+#if 0
 #ifdef VBOX_WITH_PCI_PASSTHROUGH
 HRESULT Console::attachRawPCIDevices(PUVM pUVM, BusAssignmentManager *pBusMgr, PCFGMNODE pDevices)
 {
@@ -741,6 +746,7 @@ HRESULT Console::attachRawPCIDevices(PUVM pUVM, BusAssignmentManager *pBusMgr, P
 }
 #endif
 
+#endif /* if 0 */
 
 void Console::attachStatusDriver(PCFGMNODE pCtlInst, PPDMLED *papLeds,
                                  uint64_t uFirst, uint64_t uLast,
@@ -2070,6 +2076,8 @@ int Console::configConstructorInner(PUVM pUVM, PVM pVM, AutoWriteLock *pAlock)
                 case NetworkAdapterType_I82545EM:
                     InsertConfigInteger(pCfg, "AdapterType", 2);
                     break;
+                default:
+                    break;
             }
 
             /*
@@ -2225,6 +2233,7 @@ int Console::configConstructorInner(PUVM pUVM, PVM pVM, AutoWriteLock *pAlock)
         /*
          * Parallel (LPT) Ports
          */
+#if 0
         InsertConfigNode(pDevices, "parallel", &pDev);
         for (ULONG ulInstance = 0; ulInstance < SchemaDefs::ParallelPortCount; ++ulInstance)
         {
@@ -2254,6 +2263,7 @@ int Console::configConstructorInner(PUVM pUVM, PVM pVM, AutoWriteLock *pAlock)
             InsertConfigString(pLunL1,  "DevicePath", bstr);
         }
 
+#endif
         /*
          * VMM Device
          */
@@ -2286,6 +2296,7 @@ int Console::configConstructorInner(PUVM pUVM, PVM pVM, AutoWriteLock *pAlock)
         /*
          * Audio Sniffer Device
          */
+#if 0
         InsertConfigNode(pDevices, "AudioSniffer", &pDev);
         InsertConfigNode(pDev,     "0", &pInst);
         InsertConfigNode(pInst,    "Config", &pCfg);
@@ -2300,6 +2311,7 @@ int Console::configConstructorInner(PUVM pUVM, PVM pVM, AutoWriteLock *pAlock)
         /*
          * AC'97 ICH / SoundBlaster16 audio / Intel HD Audio
          */
+#endif
         BOOL fAudioEnabled = FALSE;
         ComPtr<IAudioAdapter> audioAdapter;
         hrc = pMachine->COMGETTER(AudioAdapter)(audioAdapter.asOutParam());                 H();
@@ -2421,6 +2433,8 @@ int Console::configConstructorInner(PUVM pUVM, PVM pVM, AutoWriteLock *pAlock)
                     break;
                 }
 #endif
+                default:
+                    break;
             }
             hrc = pMachine->COMGETTER(Name)(bstr.asOutParam());                             H();
             InsertConfigString(pCfg, "StreamName", bstr);
@@ -2523,7 +2537,6 @@ int Console::configConstructorInner(PUVM pUVM, PVM pVM, AutoWriteLock *pAlock)
 #endif
             } /* for every USB controller. */
 
-
             /*
              * Virtual USB Devices.
              */
@@ -2652,6 +2665,18 @@ int Console::configConstructorInner(PUVM pUVM, PVM pVM, AutoWriteLock *pAlock)
             }
         }
 
+        extern bool use_xhci_controller();
+        if (use_xhci_controller()) {
+            /*
+             * NEC XHCI Device
+             */
+            InsertConfigNode(pDevices, "nec-xhci", &pDev);
+            InsertConfigNode(pDev,     "0",        &pInst);
+            InsertConfigNode(pInst,    "Config",   &pCfg);
+            InsertConfigInteger(pInst, "Trusted",  1);
+            hrc = pBusMgr->assignPCIDevice("nec-xhci", pInst);                  H();
+        }
+
         /*
          * Clipboard
          */
@@ -3533,6 +3558,8 @@ int Console::configMediumAttachment(PCFGMNODE pCtlInst,
         ComPtr<IMedium> pMedium;
         hrc = pMediumAtt->COMGETTER(Medium)(pMedium.asOutParam());                          H();
 
+#if 0
+
         /*
          * 1. Only check this for hard disk images.
          * 2. Only check during VM creation and not later, especially not during
@@ -3717,6 +3744,8 @@ int Console::configMediumAttachment(PCFGMNODE pCtlInst,
             }
         }
 
+#endif  /* if 0 */
+
         if (pMedium)
         {
             BOOL fHostDrive;
@@ -3810,7 +3839,7 @@ int Console::configMedium(PCFGMNODE pLunL0,
     // InsertConfig* throws
     try
     {
-        int rc = VINF_SUCCESS;
+//        int rc = VINF_SUCCESS;
         HRESULT hrc;
         Bstr bstr;
         PCFGMNODE pLunL1 = NULL;
@@ -4414,7 +4443,7 @@ int Console::configNetwork(const char *pszDevice,
                 {
                     switch (hrc)
                     {
-                        case VERR_ACCESS_DENIED:
+                        case E_ACCESSDENIED:
                             return VMSetError(VMR3GetVM(mpUVM), VERR_HOSTIF_INIT_FAILED, RT_SRC_POS,  N_(
                                             "Failed to open '/dev/net/tun' for read/write access. Please check the "
                                             "permissions of that node. Either run 'chmod 0666 /dev/net/tun' or "
@@ -4428,12 +4457,12 @@ int Console::configNetwork(const char *pszDevice,
                     }
                 }
 
-                Assert((int)maTapFD[uInstance] >= 0);
-                if ((int)maTapFD[uInstance] >= 0)
+                Assert((long)maTapFD[uInstance] >= 0);
+                if ((long)maTapFD[uInstance] >= 0)
                 {
                     InsertConfigString(pLunL0, "Driver", "HostInterface");
                     InsertConfigNode(pLunL0, "Config", &pCfg);
-                    InsertConfigInteger(pCfg, "FileHandle", maTapFD[uInstance]);
+                    InsertConfigInteger(pCfg, "FileHandle", (long)maTapFD[uInstance]);
                 }
 
 #elif defined(VBOX_WITH_NETFLT)
@@ -5180,6 +5209,10 @@ int Console::configNetwork(const char *pszDevice,
 
 #undef H
 
+	/* store the slot index for later */
+	InsertConfigInteger(pCfg, "Slot", uInstance);
+
+
     return VINF_SUCCESS;
 }
 
diff --git a/src/app/virtualbox/src/VBox/Main/src-client/DisplayImpl.cpp b/src/app/virtualbox/src/VBox/Main/src-client/DisplayImpl.cpp
index fed0ac3..bc3c334 100644
--- a/src/app/virtualbox/src/VBox/Main/src-client/DisplayImpl.cpp
+++ b/src/app/virtualbox/src/VBox/Main/src-client/DisplayImpl.cpp
@@ -16,7 +16,9 @@
 #include "DisplayImpl.h"
 #include "DisplayUtils.h"
 #include "ConsoleImpl.h"
+#if 0
 #include "ConsoleVRDPServer.h"
+#endif
 #include "GuestImpl.h"
 #include "VMMDev.h"
 
@@ -1067,7 +1070,9 @@ void Display::handleResizeCompletedEMT(BOOL fResizeContext)
          * Must be done before calling NotifyUpdate below.
          */
         LogRelFlowFunc(("Calling VRDP\n"));
+#if 0
         mParent->consoleVRDPServer()->SendResize();
+#endif
 
         /* @todo Merge these two 'if's within one 'if (!pFBInfo->pFramebuffer.isNull())' */
         if (uScreenId == VBOX_VIDEO_PRIMARY_SCREEN && !pFBInfo->pFramebuffer.isNull())
@@ -1266,8 +1271,10 @@ void Display::handleDisplayUpdate (unsigned uScreenId, int x, int y, int w, int
         /* When VBVA is enabled, the VRDP server is informed in the VideoAccelFlush.
          * Inform the server here only if VBVA is disabled.
          */
+#if 0
         if (maFramebuffers[uScreenId].u32ResizeStatus == ResizeStatus_Void)
             mParent->consoleVRDPServer()->SendUpdateBitmap(uScreenId, x, y, w, h);
+#endif
     }
 }
 
@@ -2260,7 +2267,9 @@ void Display::videoAccelFlush (void)
                 vbvaRgnDirtyRect (&rgn, uScreenId, phdr);
 
                 /* Forward the command to VRDP server. */
+#if 0
                 mParent->consoleVRDPServer()->SendUpdate (uScreenId, phdr, cbCmd);
+#endif
 
                 *phdr = hdrSaved;
             }
@@ -3248,9 +3257,11 @@ int Display::drawToScreenEMT(Display *pDisplay, ULONG aScreenId, BYTE *address,
         rc = VERR_INVALID_PARAMETER;
     }
 
+#if 0
     if (   RT_SUCCESS(rc)
         && pDisplay->maFramebuffers[aScreenId].u32ResizeStatus == ResizeStatus_Void)
         pDisplay->mParent->consoleVRDPServer()->SendUpdateBitmap(aScreenId, x, y, width, height);
+#endif
 
     pDisplay->vbvaUnlock();
     return rc;
@@ -3701,7 +3712,9 @@ DECLCALLBACK(int) Display::changeFramebuffer (Display *that, IFramebuffer *aFB,
     DISPLAYFBINFO *pDisplayFBInfo = &that->maFramebuffers[uScreenId];
     pDisplayFBInfo->pFramebuffer = aFB;
 
+#if 0
     that->mParent->consoleVRDPServer()->SendResize ();
+#endif
 
     /* The driver might not have been constructed yet */
     if (that->mpDrv)
@@ -3877,8 +3890,10 @@ DECLCALLBACK(void) Display::displayRefreshCallback(PPDMIDISPLAYCONNECTOR pInterf
 
                 if (!pFBInfo->pFramebuffer.isNull() && pFBInfo->u32ResizeStatus == ResizeStatus_Void)
                 {
+#if 0
                     Assert (pDisplay->mParent && pDisplay->mParent->consoleVRDPServer());
                     pDisplay->mParent->consoleVRDPServer()->SendUpdate (uScreenId, NULL, 0);
+#endif
                 }
             }
         }
@@ -4758,7 +4773,9 @@ DECLCALLBACK(void) Display::displayVBVAUpdateProcess(PPDMIDISPLAYCONNECTOR pInte
         pHdrUnconst->y -= (int16_t)pFBInfo->yOrigin;
 
         /* @todo new SendUpdate entry which can get a separate cmd header or coords. */
+#if 0
         pThis->mParent->consoleVRDPServer()->SendUpdate (uScreenId, pCmd, (uint32_t)cbCmd);
+#endif
 
         *pHdrUnconst = hdrSaved;
     }
@@ -5004,7 +5021,9 @@ DECLCALLBACK(int) Display::displayVBVAResize(PPDMIDISPLAYCONNECTOR pInterface, c
         {
             /* VRDP server still need this notification. */
             LogRelFlowFunc(("Calling VRDP\n"));
+#if 0
             pThis->mParent->consoleVRDPServer()->SendResize();
+#endif
         }
         return VINF_SUCCESS;
     }
diff --git a/src/app/virtualbox/src/VBox/Main/src-client/GuestImpl.cpp b/src/app/virtualbox/src/VBox/Main/src-client/GuestImpl.cpp
index b438f9d..2b9755e 100644
--- a/src/app/virtualbox/src/VBox/Main/src-client/GuestImpl.cpp
+++ b/src/app/virtualbox/src/VBox/Main/src-client/GuestImpl.cpp
@@ -16,6 +16,7 @@
  */
 
 #include "GuestImpl.h"
+#include "MachineImpl.h"
 #include "GuestSessionImpl.h"
 
 #include "Global.h"
@@ -104,11 +105,11 @@ HRESULT Guest::init(Console *aParent)
     mVmValidStats = pm::VMSTATMASK_NONE;
 
     mMagic = GUEST_MAGIC;
+#ifdef VBOX_WITH_GUEST_CONTROL
     int vrc = RTTimerLRCreate(&mStatTimer, 1000 /* ms */,
                               &Guest::staticUpdateStats, this);
     AssertMsgRC(vrc, ("Failed to create guest statistics update timer (%Rrc)\n", vrc));
 
-#ifdef VBOX_WITH_GUEST_CONTROL
     hr = unconst(mEventSource).createObject();
     if (SUCCEEDED(hr))
         hr = mEventSource->init();
@@ -183,6 +184,7 @@ void Guest::uninit()
     LogFlowFuncLeave();
 }
 
+#ifdef VBOX_WITH_GUEST_CONTROL
 /* static */
 DECLCALLBACK(void) Guest::staticUpdateStats(RTTIMERLR hTimerLR, void *pvUser, uint64_t iTick)
 {
@@ -194,6 +196,7 @@ DECLCALLBACK(void) Guest::staticUpdateStats(RTTIMERLR hTimerLR, void *pvUser, ui
 
     NOREF(hTimerLR);
 }
+#endif
 
 /* static */
 int Guest::staticEnumStatsCallback(const char *pszName, STAMTYPE enmType, void *pvSample, STAMUNIT enmUnit,
@@ -1177,8 +1180,11 @@ void Guest::onUserStateChange(Bstr aUser, Bstr aDomain, VBoxGuestUserState enmSt
 
     Bstr strDetails; /** @todo Implement state details here. */
 
+#ifdef VBOX_WITH_GUEST_CONTROL
     fireGuestUserStateChangedEvent(mEventSource, aUser.raw(), aDomain.raw(),
                                    (GuestUserState_T)enmState, strDetails.raw());
+#endif
+
     LogFlowFuncLeave();
 }
 
diff --git a/src/app/virtualbox/src/VBox/Main/src-client/MouseImpl.cpp b/src/app/virtualbox/src/VBox/Main/src-client/MouseImpl.cpp
index 652f2df..877b775 100644
--- a/src/app/virtualbox/src/VBox/Main/src-client/MouseImpl.cpp
+++ b/src/app/virtualbox/src/VBox/Main/src-client/MouseImpl.cpp
@@ -816,7 +816,11 @@ HRESULT Mouse::putEventMultiTouch(LONG aCount,
         }
     }
 
-    if (SUCCEEDED(rc))
+    /*
+     * Contrary to the comment of the previous if clause, the usb model
+     * triggers various assertions if 0 contacts are propagated.
+     */
+    if (SUCCEEDED(rc) && cContacts)
     {
         rc = reportMultiTouchEventToDevice(cContacts, cContacts? pau64Contacts: NULL, (uint32_t)aScanTime);
 
diff --git a/src/app/virtualbox/src/VBox/Main/src-client/SessionImpl.cpp b/src/app/virtualbox/src/VBox/Main/src-client/SessionImpl.cpp
index 6ea10d3..267be48 100644
--- a/src/app/virtualbox/src/VBox/Main/src-client/SessionImpl.cpp
+++ b/src/app/virtualbox/src/VBox/Main/src-client/SessionImpl.cpp
@@ -17,8 +17,11 @@
 
 #include "SessionImpl.h"
 #include "ConsoleImpl.h"
+#include "MachineImpl.h"
 #include "Global.h"
+#if 0
 #include "ClientTokenHolder.h"
+#endif
 
 #include "AutoCaller.h"
 #include "Logging.h"
@@ -26,6 +29,8 @@
 #include <VBox/err.h>
 #include <iprt/process.h>
 
+#include "console.h"
+
 /**
  *  Local macro to check whether the session is open and return an error if not.
  *  @note Don't forget to do |Auto[Reader]Lock alock (this);| before using this
@@ -329,7 +334,9 @@ STDMETHODIMP Session::AssignMachine(IMachine *aMachine, LockType_T aLockType,
 
     /* query IInternalMachineControl interface */
     mControl = aMachine;
+#if 0
     AssertReturn(!!mControl, E_FAIL);
+#endif
 
 #ifndef VBOX_COM_INPROC_API_CLIENT
     HRESULT rc = mConsole.createObject();
@@ -349,6 +356,7 @@ STDMETHODIMP Session::AssignMachine(IMachine *aMachine, LockType_T aLockType,
     AssertPtr(aToken);
 #endif /* VBOX_WITH_GENERIC_SESSION_WATCHER */
     /* create the machine client token */
+#if 0
     try
     {
 #ifndef VBOX_WITH_GENERIC_SESSION_WATCHER
@@ -367,6 +375,7 @@ STDMETHODIMP Session::AssignMachine(IMachine *aMachine, LockType_T aLockType,
     {
         rc = E_OUTOFMEMORY;
     }
+#endif
 
     /*
      *  Reference the VirtualBox object to ensure the server is up
@@ -1217,12 +1226,14 @@ HRESULT Session::unlockMachine(bool aFinalRelease, bool aFromServer, AutoWriteLo
 
     if (mType == SessionType_WriteLock)
     {
+#if 0
         if (mClientTokenHolder)
         {
             delete mClientTokenHolder;
             mClientTokenHolder = NULL;
         }
 
+#endif
         if (!aFinalRelease && !aFromServer)
         {
             /*
diff --git a/src/app/virtualbox/src/VBox/Main/src-client/VBoxDriversRegister.cpp b/src/app/virtualbox/src/VBox/Main/src-client/VBoxDriversRegister.cpp
index 7fa0f99..d85976d 100644
--- a/src/app/virtualbox/src/VBox/Main/src-client/VBoxDriversRegister.cpp
+++ b/src/app/virtualbox/src/VBox/Main/src-client/VBoxDriversRegister.cpp
@@ -25,7 +25,9 @@
 #include "VMMDev.h"
 #include "AudioSnifferInterface.h"
 #include "Nvram.h"
+#if 0
 #include "UsbWebcamInterface.h"
+#endif
 #ifdef VBOX_WITH_USB_CARDREADER
 # include "UsbCardReader.h"
 #endif
@@ -46,7 +48,7 @@
  * @param   pCallbacks      Pointer to the callback table.
  * @param   u32Version      VBox version number.
  */
-extern "C" DECLEXPORT(int) VBoxDriversRegister(PCPDMDRVREGCB pCallbacks, uint32_t u32Version)
+extern "C" DECLEXPORT(int) VBoxDriversRegister_Main(PCPDMDRVREGCB pCallbacks, uint32_t u32Version)
 {
     LogFlow(("VBoxDriversRegister: u32Version=%#x\n", u32Version));
     AssertReleaseMsg(u32Version == VBOX_VERSION, ("u32Version=%#x VBOX_VERSION=%#x\n", u32Version, VBOX_VERSION));
@@ -67,6 +69,7 @@ extern "C" DECLEXPORT(int) VBoxDriversRegister(PCPDMDRVREGCB pCallbacks, uint32_
     if (RT_FAILURE(rc))
         return rc;
 
+#if 0
     rc = pCallbacks->pfnRegister(pCallbacks, &AudioSniffer::DrvReg);
     if (RT_FAILURE(rc))
         return rc;
@@ -78,6 +81,7 @@ extern "C" DECLEXPORT(int) VBoxDriversRegister(PCPDMDRVREGCB pCallbacks, uint32_
     rc = pCallbacks->pfnRegister(pCallbacks, &EmWebcam::DrvReg);
     if (RT_FAILURE(rc))
         return rc;
+#endif
 
 #ifdef VBOX_WITH_USB_CARDREADER
     rc = pCallbacks->pfnRegister(pCallbacks, &UsbCardReader::DrvReg);
diff --git a/src/app/virtualbox/src/VBox/Main/src-client/VMMDevInterface.cpp b/src/app/virtualbox/src/VBox/Main/src-client/VMMDevInterface.cpp
index b4f4da4..a341e45 100644
--- a/src/app/virtualbox/src/VBox/Main/src-client/VMMDevInterface.cpp
+++ b/src/app/virtualbox/src/VBox/Main/src-client/VMMDevInterface.cpp
@@ -553,7 +553,9 @@ DECLCALLBACK(int) vmmdevIsPageFusionEnabled(PPDMIVMMDEVCONNECTOR pInterface, boo
 {
     PDRVMAINVMMDEV pDrv = PDMIVMMDEVCONNECTOR_2_MAINVMMDEV(pInterface);
     Console *pConsole = pDrv->pVMMDev->getParent();
+#if 0
     BOOL           val = 0;
+#endif
 
     if (!pfPageFusionEnabled)
         return VERR_INVALID_POINTER;
diff --git a/src/app/virtualbox/src/VBox/Main/src-server/ClientToken.cpp b/src/app/virtualbox/src/VBox/Main/src-server/ClientToken.cpp
index be0afb8..54d5ba4 100644
--- a/src/app/virtualbox/src/VBox/Main/src-server/ClientToken.cpp
+++ b/src/app/virtualbox/src/VBox/Main/src-server/ClientToken.cpp
@@ -179,11 +179,7 @@ Machine::ClientToken::ClientToken(const ComObjPtr<Machine> &pMachine,
         {
             mClientToken = pToken;
             if (mClientToken)
-            {
-                rc = mClientToken->AddRef();
-                if (FAILED(rc))
-                    mClientToken = NULL;
-            }
+               mClientToken->AddRef();
         }
     }
     pToken.setNull();
diff --git a/src/app/virtualbox/src/VBox/Main/src-server/DHCPServerImpl.cpp b/src/app/virtualbox/src/VBox/Main/src-server/DHCPServerImpl.cpp
index 1cd7ce7..366d693 100644
--- a/src/app/virtualbox/src/VBox/Main/src-server/DHCPServerImpl.cpp
+++ b/src/app/virtualbox/src/VBox/Main/src-server/DHCPServerImpl.cpp
@@ -20,6 +20,7 @@
 #include <string>
 #include "NetworkServiceRunner.h"
 #include "DHCPServerImpl.h"
+#include "MachineImpl.h"
 #include "AutoCaller.h"
 #include "Logging.h"
 
diff --git a/src/app/virtualbox/src/VBox/Main/src-server/MachineImpl.cpp b/src/app/virtualbox/src/VBox/Main/src-server/MachineImpl.cpp
index 3889a01..5fcb53c 100644
--- a/src/app/virtualbox/src/VBox/Main/src-server/MachineImpl.cpp
+++ b/src/app/virtualbox/src/VBox/Main/src-server/MachineImpl.cpp
@@ -3826,8 +3826,10 @@ STDMETHODIMP Machine::LockMachine(ISession *aSession,
             /* request an IUnknown pointer early from the remote party for later
              * identity checks (it will be internally cached within mDirectControl
              * at least on XPCOM) */
+#if 0
             ComPtr<IUnknown> unk = mData->mSession.mDirectControl;
             NOREF(unk);
+#endif
         }
 
         /* Release the lock since SessionMachine::uninit() locks VirtualBox which
@@ -4920,7 +4922,7 @@ STDMETHODIMP Machine::SetHotPluggableForDevice(IN_BSTR aControllerName, LONG aCo
 STDMETHODIMP Machine::SetNoBandwidthGroupForDevice(IN_BSTR aControllerName, LONG aControllerPort,
                                                    LONG aDevice)
 {
-    int rc = S_OK;
+    HRESULT rc = S_OK;
     LogFlowThisFunc(("aControllerName=\"%ls\" aControllerPort=%d aDevice=%d\n",
                      aControllerName, aControllerPort, aDevice));
 
@@ -5014,7 +5016,7 @@ STDMETHODIMP Machine::UnmountMedium(IN_BSTR aControllerName,
                                     LONG    aDevice,
                                     BOOL    aForce)
 {
-     int rc = S_OK;
+     HRESULT rc = S_OK;
      LogFlowThisFunc(("aControllerName=\"%ls\" aControllerPort=%d aDevice=%d",
                       aControllerName, aControllerPort, aForce));
 
@@ -5029,7 +5031,7 @@ STDMETHODIMP Machine::MountMedium(IN_BSTR aControllerName,
                                   IMedium *aMedium,
                                   BOOL aForce)
 {
-    int rc = S_OK;
+    HRESULT rc = S_OK;
     LogFlowThisFunc(("aControllerName=\"%ls\" aControllerPort=%d aDevice=%d aForce=%d\n",
                      aControllerName, aControllerPort, aDevice, aForce));
 
@@ -8025,7 +8027,9 @@ HRESULT Machine::launchVMProcess(IInternalSessionControl *aControl,
     size_t cchBufLeft = strlen(szPath);
     szPath[cchBufLeft++] = RTPATH_DELIMITER;
     szPath[cchBufLeft] = 0;
+#ifdef VBOX_WITH_QTGUI
     char *pszNamePart = szPath + cchBufLeft;
+#endif
     cchBufLeft = sizeof(szPath) - cchBufLeft;
 
     int vrc = VINF_SUCCESS;
@@ -8500,6 +8508,7 @@ HRESULT Machine::prepareRegister()
 
     // Ensure the settings are saved. If we are going to be registered and
     // no config file exists yet, create it by calling saveSettings() too.
+#if 0
     if (    (mData->flModifications)
          || (!mData->pMachineConfigFile->fileExists())
        )
@@ -8509,6 +8518,7 @@ HRESULT Machine::prepareRegister()
                 // we can't have a machine XML file rename pending
         if (FAILED(rc)) return rc;
     }
+#endif 
 
     /* more config checking goes here */
 
@@ -8740,9 +8750,8 @@ HRESULT Machine::initDataAndChildObjects()
 {
     AutoCaller autoCaller(this);
     AssertComRCReturnRC(autoCaller.rc());
-    AssertComRCReturn(autoCaller.state() == InInit ||
+    AssertReturn(autoCaller.state() == InInit ||
                       autoCaller.state() == Limited, E_FAIL);
-
     AssertReturn(!mData->mAccessible, E_FAIL);
 
     /* allocate data structures */
@@ -9097,7 +9106,7 @@ HRESULT Machine::loadMachineDataFromSettings(const settings::MachineConfigFile &
                         cbOut,
                         DECODE_STR_MAX);
     com::SafeArray<BYTE> iconByte(cbOut);
-    HRESULT rc = RTBase64Decode(pszStr, iconByte.raw(), cbOut, NULL, NULL);
+    HRESULT rc = Global::vboxStatusCodeToCOM(RTBase64Decode(pszStr, iconByte.raw(), cbOut, NULL, NULL));
     if (FAILED(rc))
         return setError(E_FAIL,
                         tr("Failure to Decode Icon Data. '%s' (%d)"),
@@ -12844,7 +12853,9 @@ HRESULT SessionMachine::init(Machine *aMachine)
 
     AssertReturn(aMachine, E_INVALIDARG);
 
+#if 0
     AssertReturn(aMachine->lockHandle()->isWriteLockOnCurrentThread(), E_FAIL);
+#endif
 
     /* Enclose the state transition NotReady->InInit->Ready */
     AutoInitSpan autoInitSpan(this);
@@ -12975,7 +12986,7 @@ void SessionMachine::uninit(Uninit::Reason aReason)
      *  accessing any members (and before AutoUninitSpan that does it as well).
      *  This self reference will be released as the very last step on return.
      */
-    ComObjPtr<SessionMachine> selfRef = this;
+//    ComObjPtr<SessionMachine> selfRef = this;
 
     /* Enclose the state transition Ready->InUninit->NotReady */
     AutoUninitSpan autoUninitSpan(this);
@@ -13464,12 +13475,12 @@ STDMETHODIMP SessionMachine::EndPoweringDown(LONG iResult, IN_BSTR aErrMsg)
     {
         Utf8Str strErrMsg(aErrMsg);
         if (strErrMsg.length())
-            mConsoleTaskData.mProgress->notifyComplete(iResult,
+            mConsoleTaskData.mProgress->notifyComplete(Global::vboxStatusCodeToCOM(iResult),
                                                        COM_IIDOF(ISession),
                                                        getComponentName(),
                                                        strErrMsg.c_str());
         else
-            mConsoleTaskData.mProgress->notifyComplete(iResult);
+            mConsoleTaskData.mProgress->notifyComplete(Global::vboxStatusCodeToCOM(iResult));
     }
 
     /* clear out the temporary saved state data */
@@ -13679,8 +13690,8 @@ STDMETHODIMP SessionMachine::OnSessionEnd(ISession *aSession,
         Assert(mData->mSession.mProgress.isNull());
         ComObjPtr<ProgressProxy> progress;
         progress.createObject();
-        ComPtr<IUnknown> pPeer(mPeer);
-        progress->init(mParent, pPeer,
+//        ComPtr<IUnknown> pPeer(mPeer);
+        progress->init(mParent, nullptr,
                        Bstr(tr("Closing session")).raw(),
                        FALSE /* aCancelable */);
         progress.queryInterfaceTo(aProgress);
@@ -13787,7 +13798,7 @@ STDMETHODIMP SessionMachine::EndSavingState(LONG iResult, IN_BSTR aErrMsg)
     if (FAILED(iResult))
         setMachineState(mConsoleTaskData.mLastState);
 
-    return endSavingState(iResult, aErrMsg);
+    return endSavingState(Global::vboxStatusCodeToCOM(iResult), aErrMsg);
 }
 
 /**
diff --git a/src/app/virtualbox/src/VBox/Main/src-server/MachineImplCloneVM.cpp b/src/app/virtualbox/src/VBox/Main/src-server/MachineImplCloneVM.cpp
index 3a7507d..ce9a2b3 100644
--- a/src/app/virtualbox/src/VBox/Main/src-server/MachineImplCloneVM.cpp
+++ b/src/app/virtualbox/src/VBox/Main/src-server/MachineImplCloneVM.cpp
@@ -889,7 +889,7 @@ HRESULT MachineCloneVM::start(IProgress **pProgress)
         rc = d->pProgress.createObject();
         if (FAILED(rc)) throw rc;
         rc = d->pProgress->init(p->getVirtualBox(),
-                                static_cast<IMachine*>(d->pSrcMachine) /* aInitiator */,
+                                nullptr /* aInitiator */,
                                 Bstr(p->tr("Cloning Machine")).raw(),
                                 true /* fCancellable */,
                                 uCount,
diff --git a/src/app/virtualbox/src/VBox/Main/src-server/MediumImpl.cpp b/src/app/virtualbox/src/VBox/Main/src-server/MediumImpl.cpp
index c61ea6f..ed4bb7a 100644
--- a/src/app/virtualbox/src/VBox/Main/src-server/MediumImpl.cpp
+++ b/src/app/virtualbox/src/VBox/Main/src-server/MediumImpl.cpp
@@ -20,7 +20,9 @@
 #include "ProgressImpl.h"
 #include "SystemPropertiesImpl.h"
 #include "VirtualBoxImpl.h"
+#include "TokenImpl.h"
 
+#include "Global.h"
 #include "AutoCaller.h"
 #include "Logging.h"
 
@@ -697,7 +704,7 @@ DECLCALLBACK(int) Medium::Task::fntMediumTask(RTTHREAD aThread, void *pvUser)
     delete pTask;
 
     /* complete the progress if run asynchronously */
-    if (!pProgress.isNull())
+    if (pProgress && !pProgress.isNull())
         pProgress->notifyComplete(rc);
 
     LogFlowFunc(("rc=%Rhrc\n", rc));
@@ -1231,7 +1238,7 @@ HRESULT Medium::init(VirtualBox *aVirtualBox,
         else
         {
             // Otherwise use the old VirtualBox "make absolute path" logic:
-            rc = m->pVirtualBox->calculateFullPath(data.strLocation, strFull);
+            rc = Global::vboxStatusCodeToCOM(m->pVirtualBox->calculateFullPath(data.strLocation, strFull));
             if (FAILED(rc)) return rc;
         }
     }
@@ -2578,7 +2585,7 @@ STDMETHODIMP Medium::CreateBaseStorage(LONG64 aLogicalSize,
 
         pProgress.createObject();
         rc = pProgress->init(m->pVirtualBox,
-                             static_cast<IMedium*>(this),
+                             nullptr,
                              (mediumVariantFlags & MediumVariant_Fixed)
                                ? BstrFmt(tr("Creating fixed medium storage unit '%s'"), m->strLocationFull.c_str()).raw()
                                : BstrFmt(tr("Creating dynamic medium storage unit '%s'"), m->strLocationFull.c_str()).raw(),
@@ -2758,7 +2765,7 @@ STDMETHODIMP Medium::CloneToBase(IMedium   *aTarget,
                                   ComSafeArrayIn(MediumVariant_T, aVariant),
                                   IProgress **aProgress)
 {
-     int rc = S_OK;
+     HRESULT rc = S_OK;
      CheckComArgNotNull(aTarget);
      CheckComArgOutPointerValid(aProgress);
      CheckComArgSafeArrayNotNull(aVariant);
diff --git a/src/app/virtualbox/src/VBox/Main/src-server/MediumLock.cpp b/src/app/virtualbox/src/VBox/Main/src-server/MediumLock.cpp
index 567973d..2cda8b2 100644
--- a/src/app/virtualbox/src/VBox/Main/src-server/MediumLock.cpp
+++ b/src/app/virtualbox/src/VBox/Main/src-server/MediumLock.cpp
@@ -18,7 +18,7 @@
 #include "MediumLock.h"
 #include "MediumImpl.h"
 #include "MediumAttachmentImpl.h"
-
+#include "TokenImpl.h"
 
 MediumLock::MediumLock()
     : mMedium(NULL), mMediumCaller(NULL), mLockWrite(false),
diff --git a/src/app/virtualbox/src/VBox/Main/src-server/NetworkAdapterImpl.cpp b/src/app/virtualbox/src/VBox/Main/src-server/NetworkAdapterImpl.cpp
index e3908bb..c5cee5c 100644
--- a/src/app/virtualbox/src/VBox/Main/src-server/NetworkAdapterImpl.cpp
+++ b/src/app/virtualbox/src/VBox/Main/src-server/NetworkAdapterImpl.cpp
@@ -1332,7 +1332,7 @@ HRESULT NetworkAdapter::saveSettings(settings::NetworkAdapter &data)
 bool NetworkAdapter::isModified() {
     AutoWriteLock alock(this COMMA_LOCKVAL_SRC_POS);
     bool fChanged = m_fModified;
-    fChanged |= (mData->mAdapterType == NetworkAttachmentType_NAT? mNATEngine->isModified() : false);
+    fChanged |= (mData->mAttachmentType == NetworkAttachmentType_NAT? mNATEngine->isModified() : false);
     return fChanged;
 }
 
diff --git a/src/app/virtualbox/src/VBox/Main/src-server/SnapshotImpl.cpp b/src/app/virtualbox/src/VBox/Main/src-server/SnapshotImpl.cpp
index ddce18b..55065d2 100644
--- a/src/app/virtualbox/src/VBox/Main/src-server/SnapshotImpl.cpp
+++ b/src/app/virtualbox/src/VBox/Main/src-server/SnapshotImpl.cpp
@@ -24,6 +24,7 @@
 #include "MediumFormatImpl.h"
 #include "Global.h"
 #include "ProgressImpl.h"
+#include "TokenImpl.h"
 
 // @todo these three includes are required for about one or two lines, try
 // to remove them and put that code in shared code in MachineImplcpp
@@ -2863,7 +2864,7 @@ void SessionMachine::deleteSnapshotHandler(DeleteSnapshotTask &aTask)
                 ComObjPtr<Snapshot> pChildSnapshot = aTask.pSnapshot->getFirstChild();
                 if (pChildSnapshot)
                 {
-                    pMachine = pChildSnapshot->getSnapshotMachine();
+                    pMachine = &*pChildSnapshot->getSnapshotMachine();
                     childSnapshotId = pChildSnapshot->getId();
                 }
                 pAtt = findAttachment(pMachine->mMediaData->mAttachments, it->mpSource);
diff --git a/src/app/virtualbox/src/VBox/Main/src-server/VRDEServerImpl.cpp b/src/app/virtualbox/src/VBox/Main/src-server/VRDEServerImpl.cpp
index a717aff..3d52b9f 100644
--- a/src/app/virtualbox/src/VBox/Main/src-server/VRDEServerImpl.cpp
+++ b/src/app/virtualbox/src/VBox/Main/src-server/VRDEServerImpl.cpp
@@ -31,7 +31,7 @@
 #include <VBox/sup.h>
 #include <VBox/com/array.h>
 
-#include <VBox/RemoteDesktop/VRDE.h>
+//#include <VBox/RemoteDesktop/VRDE.h>
 
 #include "AutoStateDep.h"
 #include "AutoCaller.h"
@@ -486,6 +486,7 @@ STDMETHODIMP VRDEServer::GetVRDEProperty(IN_BSTR aKey, BSTR *aValue)
     return S_OK;
 }
 
+#if 0
 static int loadVRDELibrary(const char *pszLibraryName, RTLDRMOD *phmod, PFNVRDESUPPORTEDPROPERTIES *ppfn)
 {
     int rc = VINF_SUCCESS;
@@ -530,6 +531,7 @@ static int loadVRDELibrary(const char *pszLibraryName, RTLDRMOD *phmod, PFNVRDES
 
     return rc;
 }
+#endif
 
 STDMETHODIMP VRDEServer::COMGETTER(VRDEProperties)(ComSafeArrayOut(BSTR, aProperties))
 {
@@ -584,13 +586,14 @@ STDMETHODIMP VRDEServer::COMGETTER(VRDEProperties)(ComSafeArrayOut(BSTR, aProper
         /*
          * Load the VRDE library and start the server, if it is enabled.
          */
-        PFNVRDESUPPORTEDPROPERTIES pfn = NULL;
+//        PFNVRDESUPPORTEDPROPERTIES pfn = NULL;
         RTLDRMOD hmod = NIL_RTLDRMOD;
-        vrc = loadVRDELibrary(strVrdeLibrary.c_str(), &hmod, &pfn);
+//        vrc = loadVRDELibrary(strVrdeLibrary.c_str(), &hmod, &pfn);
+        vrc = !vrc;
         Log(("VRDEPROP: load library [%s] rc %Rrc\n", strVrdeLibrary.c_str(), vrc));
         if (RT_SUCCESS(vrc))
         {
-            const char * const *papszNames = pfn();
+            const char * const *papszNames = nullptr; //pfn();
 
             if (papszNames)
             {
diff --git a/src/app/virtualbox/src/VBox/Main/src-server/VirtualBoxImpl.cpp b/src/app/virtualbox/src/VBox/Main/src-server/VirtualBoxImpl.cpp
index 9ce039a..2e6ac11 100644
--- a/src/app/virtualbox/src/VBox/Main/src-server/VirtualBoxImpl.cpp
+++ b/src/app/virtualbox/src/VBox/Main/src-server/VirtualBoxImpl.cpp
@@ -42,7 +42,9 @@
 #include <VBox/settings.h>
 #include <VBox/version.h>
 
+#if 0
 #include <package-generated.h>
+#endif
 
 #include <algorithm>
 #include <set>
@@ -1367,7 +1369,7 @@ VirtualBox::CheckFirmwarePresent(FirmwareType_T aFirmwareType,
                                RTPATH_DELIMITER,
                                firmwareDesc[i].fileName);
         int rc = calculateFullPath(shortName, fullName);
-        AssertRCReturn(rc, rc);
+        AssertRCReturn(rc, Global::vboxStatusCodeToCOM(rc));
         if (RTFileExists(fullName.c_str()))
         {
             *aResult = TRUE;
@@ -1378,7 +1380,7 @@ VirtualBox::CheckFirmwarePresent(FirmwareType_T aFirmwareType,
 
         char pszVBoxPath[RTPATH_MAX];
         rc = RTPathExecDir(pszVBoxPath, RTPATH_MAX);
-        AssertRCReturn(rc, rc);
+        AssertRCReturn(rc, Global::vboxStatusCodeToCOM(rc));
         fullName = Utf8StrFmt("%s%c%s",
                               pszVBoxPath,
                               RTPATH_DELIMITER,
@@ -4368,8 +4370,10 @@ HRESULT VirtualBox::registerMachine(Machine *aMachine)
     /* add to the collection of registered machines */
     m->allMachines.addChild(aMachine);
 
+#if 0
     if (autoCaller.state() != InInit)
         rc = saveSettings();
+#endif
 
     return rc;
 }
diff --git a/src/app/virtualbox/src/VBox/Main/xml/Settings.cpp b/src/app/virtualbox/src/VBox/Main/xml/Settings.cpp
index 3520c9c..e3288af 100644
--- a/src/app/virtualbox/src/VBox/Main/xml/Settings.cpp
+++ b/src/app/virtualbox/src/VBox/Main/xml/Settings.cpp
@@ -4922,6 +4922,8 @@ void MachineConfigFile::buildStorageControllersXML(xml::ElementNode &elmParent,
                 case DeviceType_Floppy:
                     pcszType = "Floppy";
                     break;
+                default:
+                    break;
             }
 
             pelmDevice->setAttribute("type", pcszType);
@@ -5273,6 +5275,8 @@ bool MachineConfigFile::isAudioDriverAllowedOnThisHost(AudioDriverType_T drv)
         case AudioDriverType_MMPM:
 #endif
             return true;
+        default:
+            break;
     }
 
     return false;
--- a/src/app/virtualbox/src/VBox/Main/src-server/SystemPropertiesImpl.cpp
+++ b/src/app/virtualbox/src/VBox/Main/src-server/SystemPropertiesImpl.cpp
@@ -1191,8 +1191,8 @@
 HRESULT SystemProperties::setLoggingLevel(const Utf8Str &aLoggingLevel)
 {
     Utf8Str useLoggingLevel(aLoggingLevel);
-    if (useLoggingLevel.isEmpty())
-        useLoggingLevel = VBOXSVC_LOG_DEFAULT;
+//    if (useLoggingLevel.isEmpty())
+//        useLoggingLevel = VBOXSVC_LOG_DEFAULT;
     int rc = RTLogGroupSettings(RTLogRelDefaultInstance(), useLoggingLevel.c_str());
     //  If failed and not the default logging level - try to use the default logging level.
     if (RT_FAILURE(rc))
--- a/src/app/virtualbox/include/iprt/string.h
+++ b/src/app/virtualbox/include/iprt/string.h
@@ -113,12 +113,6 @@
 RT_C_DECLS_END
 #endif
 
-#if !defined(RT_OS_LINUX) || !defined(_GNU_SOURCE)
-RT_C_DECLS_BEGIN
-void *memrchr(const char *pv, int ch, size_t cb);
-RT_C_DECLS_END
-#endif
-
 
 /** @def RT_USE_RTC_3629
  * When defined the UTF-8 range will stop at  0x10ffff.  If not defined, the
