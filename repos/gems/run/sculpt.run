#
# \brief  Sculpt OS
# \author Norman Feske
# \date   2017-09-07
#

#
# Note: the string must be exactly 5 bytes long.
#
proc sculpt_version { } { return "25.10" }


assert {[have_board pc]              ||
        [have_board imx8q_evk]       ||
        [have_board mnt_reform2]     ||
        [have_board mnt_pocket]      ||
        [have_board linux]           ||
        [have_board pinephone]       ||
        [have_board imx8mp_armstone]}


proc log_core { } {

	global ::env

	if {[info exists ::env(LOG)]} {
		if {$::env(LOG) == "core"} { return true }
	}

	return false
}


if {[log_core]} {
	if {[have_spec nova]} {
		proc kernel_output { } { return "serial logmem" }
	}
} else {
	# disable default enabled serial log output via core
	proc boot_output { } { return "" }

	if {[have_spec nova]} {
		proc kernel_output { } { return "logmem" }
	}
}


##
## Utilities for querying the ingredients of Sculpt
##

##
# Return path to the sculpt definition file that contains the list of
# ingredients
#
proc sculpt_path { } {

	global ::env

	set filename "default-[board].sculpt"
	if {[info exists ::env(SCULPT)]} {
		set filename "$::env(SCULPT)-[board].sculpt" }

	return [select_from_repositories [file join sculpt $filename]]
}


##
# Return list of ingredients of scenario supplied via the 'SCULPT' argument
#
# If 'SCULPT' is not specified, use 'sculpt/default.sculpt'.
#
proc sculpt_ingredients { } {

	global _sculpt_ingredients

	if {![info exists _sculpt_ingredients]} {
		set fh [open [sculpt_path] "RDONLY"]
		set _sculpt_ingredients [split [read $fh] "\n"]
		close $fh
	}

	return $_sculpt_ingredients
}


proc ingredients_of_type { type } {

	set result {}
	set line 1
	foreach i [sculpt_ingredients] {

		# skip comment lines
		if {[string match "#*" $i]} {
			continue }

		# skip empty lines
		if {[string match "" $i]} {
			continue }

		regexp {^(.*?):\s*(.*)\s*$} $i dummy tag values

		if {$tag == $type} {
			lappend result {*}$values}

		incr line
	}
	return $result
}


proc single_ingredient { type default } {

	set ingredient [ingredients_of_type $type]

	if {[llength $ingredient] == 0} {
		return $default }

	if {[llength $ingredient] > 1} {
		puts stderr "Error: ambigious selection of '$type' in [sculpt_path]"
		exit
	}
	return $ingredient
}


proc ingredient_path { type ingredient } {
	return [select_from_repositories [file join sculpt $type $ingredient]] }

proc initial_config_dir { } {
	return [file join [run_dir] initial_config] }

proc initial_config_file { rel_path } {
	return [file join [initial_config_dir] $rel_path] }


##
## System-image content imported from depot archives
##

create_boot_directory


proc prefixed_with_depot_user { paths } {
	return [lmap path $paths { file join [depot_user] $path }] }


import_from_depot [depot_user]/src/[base_src] \
                  [depot_user]/pkg/sculpt \
                  {*}[prefixed_with_depot_user [ingredients_of_type import]]


##
## Static init configuration
##

proc log_route { } {

	if {[log_core]} {
		return {+ service LOG | + parent} }

	return {+ service LOG | + child log}
}

# each line in the following definitions must be indented with 4 spaces

set driver_routes(pc) {
    + service ROM | label: nic               | + parent | label: pc_nic
    + service ROM | label: wifi.lib.so       | + parent | label: pc_wifi.lib.so
    + service ROM | label: wifi_firmware.tar | + parent | label: pc_wifi_firmware.tar
    + service ROM | label: usb               | + parent | label: pc_usb_host
}

set driver_routes(mnt_reform2) {
    + service ROM | label: fb                | + parent | label: imx8mq_fb
    + service ROM | label: fb.dtb            | + parent | label: imx8mq_fb-mnt_reform2.dtb
    + service ROM | label: mmc               | + parent | label: imx8mq_sd_card
    + service ROM | label: mmc.dtb           | + parent | label: imx8mq_sd_card-mnt_reform2.dtb
    + service ROM | label: nic               | + parent | label: fec_nic
    + service ROM | label: nic.dtb           | + parent | label: fec_nic-mnt_reform2.dtb
    + service ROM | label: usb               | + parent | label: imx8m_usb_host
    + service ROM | label: usb.dtb           | + parent | label: imx8m_usb_host-mnt_reform2.dtb
    + service ROM | label: wifi.lib.so       | + parent | label: imx8mq_wifi.lib.so
    + service ROM | label: wifi_firmware.tar | + parent | label: imx8mq_wifi_firmware.tar
    + service I2c                            | + child drivers
}

set driver_routes(mnt_pocket) {
    + service ROM | label: fb                | + parent | label: imx8mq_fb
    + service ROM | label: fb.dtb            | + parent | label: imx8mq_fb-mnt_pocket.dtb
    + service ROM | label: mmc               | + parent | label: imx8mq_sd_card
    + service ROM | label: mmc.dtb           | + parent | label: imx8mq_sd_card-mnt_pocket.dtb
    + service ROM | label: nic               | + parent | label: stmmac_nic
    + service ROM | label: nic.dtb           | + parent | label: stmmac_nic-mnt_pocket.dtb
    + service ROM | label: usb               | + parent | label: imx8m_usb_host
    + service ROM | label: usb.dtb           | + parent | label: imx8m_usb_host-mnt_pocket.dtb
    + service ROM | label: wifi.dtb          | + parent | label: wifi-mnt_pocket.dtb
    + service ROM | label: wifi.lib.so       | + parent | label: imx8mp_qcacld2_wifi.lib.so
    + service ROM | label: wifi_firmware.tar | + parent | label: imx8mp_qcacld2_wifi_firmware.tar
    + service I2c                            | + child drivers
}

set driver_routes(imx8q_evk) {
    + service ROM | label: nic     | + parent | label: fec_nic
    + service ROM | label: nic.dtb | + parent | label: fec_nic-imx8q_evk.dtb
}

set driver_routes(pinephone) {
    + service ROM | label: wifi.lib.so       | + parent | label: a64_wifi.lib.so
    + service ROM | label: wifi.dtb          | + parent | label: wifi-pinephone.dtb
    + service ROM | label: wifi_firmware.tar | + parent | label: a64_wifi_firmware.tar
    + service ROM | label: usb               | + parent | label: a64_usb_host
    + service ROM | label: usb.dtb           | + parent | label: usb-pinephone.dtb
    + service ROM | label: mmc               | + parent | label: a64_sd_card
    + service ROM | label: mmc.dtb           | + parent | label: sd_card-pinephone.dtb
    + service ROM | label: fb                | + parent | label: de_fb
    + service ROM | label: fb.dtb            | + parent | label: de-pinephone.dtb
    + service ROM | label: touch             | + parent | label: goodix_touch
    + service ROM | label: touch.dtb         | + parent | label: goodix-pinephone.dtb
    + service IRQ | label_prefix: touch ->   | + child drivers | label: runtime -> touch -> PH4
}

set driver_routes(imx8mp_armstone) {
    + service ROM | label: fb      | + parent | label: imx8mp_armstone_fb
    + service ROM | label: fb.dtb  | + parent | label: imx8mp_armstone_fb-imx8mp_armstone.dtb
    + service ROM | label: mmc     | + parent | label: imx8mq_sd_card
    + service ROM | label: mmc.dtb | + parent | label: imx8mq_sd_card-imx8mp_armstone.dtb
    + service ROM | label: nic     | + parent | label: fec_nic
    + service ROM | label: nic.dtb | + parent | label: fec_nic-imx8mp_armstone.dtb
    + service ROM | label: usb     | + parent | label: imx8m_usb_host
    + service ROM | label: usb.dtb | + parent | label: imx8m_usb_host-imx8mp_armstone.dtb
    + service I2c                  | + child drivers
}


##
# ROM routes that relabel generic driver names to platform-specific binaries
#
proc driver_routes { } {

	global driver_routes

	if {[info exists driver_routes([board])]} {
		return $driver_routes([board]); }

	return "";
}


proc log_core_start_node { } { if {![have_board linux]} { return {

+ start log_core | priority: -1
  + config | period_ms: 2000
  + route
    + service ROM | label: log | + parent | label: core_log
    + service Timer            | + child timer
    + service LOG | label: log | + child log | label: core
    + any-service              | + parent
} } }


proc log_kernel_start_node { } { if {[have_spec nova]} { return {

+ start log_kernel | priority: -1
  + binary log_core
  + config | period_ms: 2000
  + route
    + service ROM | label: log | + parent | label: kernel_log
    + service Timer            | + child timer
    + service LOG | label: log | + child log | label: kernel
    + any-service              | + parent
} } }


install_config {
config | prio_levels: 2

+ parent-provides
  + service ROM
  + service IRQ
  + service IO_MEM
  + service IO_PORT
  + service PD
  + service RM
  + service CPU
  + service LOG
  + service TRACE
  + service VM

+ affinity-space | width: 2 | height: 1

+ default-route
  + any-service
    + parent
    + any-child
+ default | caps: 100 | ram: 1M

+ resource RAM | preserve: 2M

+ start timer | priority: 0
  + provides | + service Timer

+ start report_rom | priority: -1 | ram: 2M
  + binary report_rom
  + provides
    + service Report
    + service ROM
  + config | verbose: no
    + policy | label: leitzentrale_config -> leitzentrale        | report: global_keys_handler -> leitzentrale
    + policy | label: leitzentrale -> manager -> leitzentrale    | report: global_keys_handler -> leitzentrale
    + policy | label: pointer -> hover                           | report: nitpicker -> hover
    + policy | label: pointer -> xray                            | report: global_keys_handler -> leitzentrale
    + policy | label: pointer -> shape                           | report: shape
    + policy | label: clipboard -> focus                         | report: nitpicker -> focus
    + policy | label: runtime -> capslock                        | report: global_keys_handler -> capslock
    + policy | label: runtime -> numlock                         | report: global_keys_handler -> numlock
    + policy | label: numlock_remap_rom -> numlock               | report: global_keys_handler -> numlock
    + policy | label: event_filter -> capslock                   | report: global_keys_handler -> capslock
    + policy | label: runtime -> clicked                         | report: nitpicker -> clicked
    + policy | label: leitzentrale -> manager -> nitpicker_focus | report: nitpicker -> focus
    + policy | label: leitzentrale -> manager -> nitpicker_hover | report: nitpicker -> hover
    + policy | label: nit_focus -> leitzentrale                  | report: global_keys_handler -> leitzentrale
    + policy | label: nit_focus -> slides                        | report: global_keys_handler -> slides
    + policy | label: nit_focus -> hover                         | report: nitpicker -> hover
    + policy | label: slides_gui_fb_config -> slides             | report: global_keys_handler -> slides

+ start report_logger | priority: -1
  + binary report_rom
  + provides
    + service Report
    + service ROM
  + config | verbose: yes

+ start config_fs | caps: 200 | ram: 12M | priority: -1
  + binary vfs
  + provides | + service File_system
  + config
    + vfs
    | + ram
    | + import
    |   + tar initial_config.tar
    + policy | label_prefix: config_fs_rom -> | root: /
    + policy | label_prefix: rw -> | root: / | writeable: yes

+ start config_fs_rom | ram: 10M | priority: -1
  + binary fs_rom
  + provides | + service ROM
  + route
    + service File_system | + child config_fs
    + any-service         | + parent

+ start report_fs_rom | ram: 3M | priority: -1
  + binary fs_rom
  + provides | + service ROM
  + route
    + service File_system | + child report_fs
    + any-service         | + parent

+ start report_fs | ram: 16M | priority: -1
  + binary vfs
  + provides | + service File_system
  + config
    + vfs
    | + ram_log log | limit: 1M
    | + ram
    | + import
    |   + dir runtime
    |     + inline state | + empty
    |     + dir nic_router  | + inline state     | + empty
    |     + dir update      | + inline state     | + empty
    |     + dir depot_query | + inline blueprint | + empty
    |
    + policy | label_prefix: fs_report ->     | root: / | writeable: yes
    + policy | label_prefix: log_terminal ->  | root: / | writeable: yes
    + policy | label_prefix: report_fs_rom -> | root: /
    + policy | label_prefix: ro ->            | root: /

+ start log_terminal | ram: 2M | priority: -1
  + binary file_terminal
  + provides | + service Terminal
  + config
  | + default-policy | filename: log
  | + vfs
  |   + dir dev | + log
  |   + fs
  | + libc | stdout: /dev/log
  + route
    + service File_system | + child report_fs
    + any-service         | + parent

+ start log | priority: -1
  + binary terminal_log
  + provides | + service LOG
  + config
  + route
    + service Terminal | + child log_terminal
    + service Timer    | + child timer
    + any-service      | + parent

} [log_core_start_node] {
} [log_kernel_start_node] {

+ start fs_report | ram: 2M | priority: -1
  + provides | + service Report
  + config | + vfs | + fs
  + route
    + service File_system | + child report_fs
    + any-service         | + parent

+ start drivers | caps: 4850 | ram: 200M | priority: -1 | managing_system: yes
  + binary init
  + route
    } [log_route] {
    + service ROM | label: config            | + child config_fs_rom | label: drivers
    + service ROM | label_last: gpu.config   | + child config_fs_rom | label: gpu
    + service ROM | label_last: system       | + child config_fs_rom | label: managed/system
    + service ROM | label_last: modem.config | + child config_fs_rom | label: managed/modem
    + service ROM | label_last: audio.config | + child config_fs_rom | label: managed/audio
    + service ROM | label_last: sleep_states | + child report_fs_rom | label: runtime/acpi_support/sleep_states
    + service Timer                          | + child timer
    + service Capture                        | + child nitpicker
    + service Event                          | + child event_filter
    + service Report                         | + child fs_report
    + any-service                            | + parent
  + provides
    + service Platform
    + service Pin_state
    + service Pin_control
    + service I2c
    + service IRQ

+ start nitpicker | caps: 1000 | ram: 18M | priority: -1
  + affinity | xpos: 1 | width: 1 | . decouple nitpicker from boot CPU
  + provides
    + service Gui
    + service Capture
    + service Event
  + route
    + service ROM | label: config      | + child config_fs_rom | label: managed/nitpicker
    + service ROM | label: focus       | + child nit_focus
    + service Report | label: panorama | + child fs_report
    + service Report | label: keystate | + child report_logger
    + service Report                   | + child report_rom
    + service Timer                    | + child timer
    + any-service                      | + parent

+ start numlock_remap_rom | priority: -1
  .
  . toggle key mappings depending on the numlock state
  .
  + binary rom_filter
  + provides | + service ROM
  + route
    + service ROM | label: config  | + child config_fs_rom | label: numlock_remap
    + service ROM | label: numlock | + child report_rom
    + any-service                  | + parent

+ start event_filter | caps: 120 | ram: 2M | priority: -1
  + provides | + service Event
  + route
    + service ROM | label: config           | + child config_fs_rom | label: managed/event_filter
    + service ROM | label_prefix: keyboard/ | + child config_fs_rom
    + service ROM | label: numlock.remap    | + child numlock_remap_rom
    + service ROM | label: capslock         | + child report_rom
    + service ROM                           | + parent
    + service PD                            | + parent
    + service CPU                           | + parent
    + service LOG                           | + parent
    + service Timer                         | + child timer
    + service Event                         | + child nitpicker

+ start nit_focus | priority: -1
  .
  . override user focus when leitzentrale is active
  .
  + binary rom_filter
  + provides | + service ROM
  + config
  | + input lockscreen_enabled   | rom: hover        | node: hover        | + attribute label
  | + input leitzentrale_enabled | rom: leitzentrale | node: leitzentrale | + attribute enabled
  | + input slides_enabled       | rom: slides       | node: slides       | + attribute enabled
  | + output | node: focus
  |   + if
  |     + has_value | input: lockscreen_enabled | value: lock_screen
  |     + then
  |     | + attribute label | value: lock_screen
  |     + else
  |       + if
  |         + has_value | input: leitzentrale_enabled | value: yes
  |         + then
  |         | + attribute label | value: leitzentrale -> manager -> fader ->
  |         + else
  |           + if
  |             + has_value | input: slides_enabled | value: yes
  |             + then
  |             | + attribute label | value: slides
  |             + else
  |               + attribute label | value: runtime -> focus
  + route
    + service ROM | label: hover        | + child report_rom
    + service ROM | label: leitzentrale | + child report_rom
    + service ROM | label: slides       | + child report_rom
    + any-service                       | + parent

+ start pointer | ram: 2M | priority: -1
  + provides | + service Report
  + config | shapes: yes
  + route
    + service Gui                | + child nitpicker
    + service ROM | label: hover | + child report_rom
    + service ROM | label: xray  | + child report_rom
    + any-service
      + parent
      + any-child

+ start global_keys_handler | priority: -1
  + route
    + service Report              | + child report_rom
    + service Gui                 | + child nitpicker
    + service Timer               | + child timer
    + service ROM | label: config | + child config_fs_rom | label: global_keys
    + any-service                 | + parent

+ start leitzentrale_config | priority: -1
  + binary rom_filter
  + provides | + service ROM
  + route
    + service ROM | label: leitzentrale | + child report_rom
    + service ROM | label: config       | + child config_fs_rom | label: leitzentrale
    + any-service                       | + parent

+ start clipboard | ram: 2M | priority: -1
  + provides
    + service ROM
    + service Report
  + route
    + service ROM | label: config | + child config_fs_rom | label: clipboard
    + service ROM | label: focus  | + child report_rom
    + any-service
      + parent
      + any-child

+ start leitzentrale | caps: 2400 | ram: 203M | priority: -1
  + binary init
  + affinity | xpos: 1 | width: 1 | . decouple leitzentrale from boot CPU
  + provides
    + service Gui
    + service Capture
    + service Event
    + service File_system | . fonts
    + service ROM         | . view dialog ROMs
    + service Report      | . view hover reports
  + route
    } [log_route] {
    + service ROM | label: config                      | + child leitzentrale_config
    + service ROM | label_prefix: report ->            | + child report_fs_rom
    + service ROM | label_prefix: manager -> report -> | + child report_fs_rom
    + service ROM | label_prefix: manager -> config -> | + child config_fs_rom
    + service ROM | label_prefix: config ->            | + child config_fs_rom
    + service ROM | label: manager -> nitpicker_focus  | + child report_rom
    + service ROM | label: manager -> nitpicker_hover  | + child report_rom
    + service ROM | label: manager -> leitzentrale     | + child report_rom
    + service Report                                   | + child fs_report
    + service Gui                                      | + child nitpicker
    + service Timer                                    | + child timer
    + service File_system | label_prefix: config ->    | + child config_fs | identity: rw
    + service File_system | label_prefix: report ->    | + child report_fs | identity: ro
    + any-service                                      | + parent

+ start terminal_monitor | ram: 2M | priority: -1
  + binary terminal_crosslink
  + provides | + service Terminal

+ start runtime | caps: 50000 | ram: 32G | priority: -1 | managing_system: yes
  + binary monitor
  + route
    + service ROM | label: config                    | + child config_fs_rom | label: managed/runtime
    + service ROM | label_prefix: config ->          | + child config_fs_rom
    + service ROM | label_prefix: report ->          | + child report_fs_rom
    + service ROM | label: capslock                  | + child report_rom
    + service ROM | label: numlock                   | + child report_rom
    + service ROM | label: clicked                   | + child report_rom
    + service File_system | label_prefix: config ->  | + child config_fs | identity: rw
    + service File_system | label_prefix: report ->  | + child report_fs | identity: ro
    + service Platform | label_prefix: acpica        | + child drivers | label: acpica
    + service Platform                               | + child drivers
    + service Gui | label_prefix: leitzentrale       | + child leitzentrale
    + service Gui | label: backdrop                  | + child nitpicker | label: backdrop
    + service Gui | label: lock_screen               | + child nitpicker | label: lock_screen
    + service Gui                                    | + child nitpicker
    + service Timer                                  | + child timer
    + service Report | label_suffix: -> shape        | + child pointer
    + service Report | label: inspect -> clipboard   | + child clipboard | label: leitzentrale -> manager -> fader ->  -> clipboard
    + service Report | label: editor -> clipboard    | + child clipboard | label: leitzentrale -> manager -> fader ->  -> clipboard
    + service ROM | label: inspect -> clipboard      | + child clipboard | label: leitzentrale -> manager -> fader ->  -> clipboard
    + service ROM | label: editor -> clipboard       | + child clipboard | label: leitzentrale -> manager -> fader ->  -> clipboard
    + service Report | label_suffix: -> clipboard    | + child clipboard
    + service ROM | label_suffix: -> clipboard       | + child clipboard
    + service Report | label_prefix: leitzentrale -> | + child leitzentrale
    + service ROM | label_prefix: leitzentrale ->    | + child leitzentrale
    + service File_system
              label_prefix: leitzentrale -> fonts -> | + child leitzentrale | identity: fonts
    + service Report                                 | + child fs_report
    + service LOG | label: unlogged                  | + parent
    } [log_route] {
    } [driver_routes] {
    + service Event | label: leitzentrale   | + child leitzentrale
    + service Event                         | + child event_filter
    + service Capture | label: leitzentrale | + child leitzentrale
    + service Capture                       | + child nitpicker
    + service Pin_state                     | + child drivers
    + service Pin_control                   | + child drivers
    + service Terminal                      | + child terminal_monitor
    + service TRACE | label: runtime        | + parent | label: runtime ->
    + service TRACE | label: global         | + parent | label:
    + any-service                           | + parent
-
}


##
## Initial content of the config file system
##

#
# The directory structure for the initial content is created at the run
# directory, which is imported as 'initial_config.tar' into the config fs.
#

# directory structure
foreach subdir { launcher depot managed keyboard } {
	file mkdir [file join [initial_config_dir] $subdir] }

if {[llength [ingredients_of_type presets]] > 0} {
	file mkdir [file join [initial_config_dir] presets] }

# configs that are managed by the sculpt manager if absent
set optional_configs {
	fonts
	nic_router
	event_filter
	wifi
	runtime
	gpu
}

foreach config $optional_configs {
	set ingredient [single_ingredient $config ""]
	if {$ingredient != ""} {
		set from [ingredient_path $config $ingredient]
		set to   [initial_config_file $config]
		copy_config $from $to } }

# configs that are expected to be always present
set required_configs {
	nitpicker
	deploy
	fb
	clipboard
	drivers
	numlock_remap
	global_keys
	leitzentrale
	usb
	system
	ram_fs
	manager
}

foreach config $required_configs {
	set ingredient [single_ingredient $config "default"]
	set from [ingredient_path $config $ingredient]
	set to   [initial_config_file $config]
	check_syntax $from
	copy_config $from $to
}


# selection of depot users (pubkey and download files), launchers, and presets
foreach ingredient [ingredients_of_type launcher] {
	check_syntax [ingredient_path launcher $ingredient] }

foreach ingredient [ingredients_of_type presets] {
	check_syntax [ingredient_path deploy $ingredient] }

foreach ingredient [ingredients_of_type depot] {
	set from [ingredient_path depot $ingredient]
	set to   [file join [initial_config_dir] depot $ingredient]
	copy_file $from $to }

foreach ingredient [ingredients_of_type launcher] {
	set from [ingredient_path launcher $ingredient]
	set to   [file join [initial_config_dir] launcher $ingredient]
	copy_config $from $to }

foreach ingredient [ingredients_of_type presets] {
	set from [ingredient_path deploy $ingredient]
	set to   [file join [initial_config_dir] presets $ingredient]
	copy_config $from $to }

copy_file [genode_dir]/repos/gems/recipes/pkg/sculpt/README [initial_config_file README]
copy_file [genode_dir]/repos/gems/run/sculpt/vimrc          [initial_config_file vimrc]

# keyboard layouts
foreach file { en_us de_ch de_de fr_ch fr_fr fr_bepo special } {
	set from [genode_dir]/repos/os/src/server/event_filter/$file.chargen
	set to   [file join [initial_config_dir] keyboard $file]
	check_syntax $from
	copy_config $from $to }


#
# Pre-populate the managed/ directory of the config fs to avoid diagnostic
# warnings by components starting up before the sculpt manager has generated
# the directory content for the first time.
#

proc managed_config_path { name } {
	return [file join [initial_config_dir] managed $name] }

set fd [open [managed_config_path installation] w]
puts $fd "installation | arch: [depot_spec]\n-"
close $fd

set fd [open [managed_config_path depot_query] w]
puts $fd "query\n-"
close $fd

foreach config { fonts wifi runtime event_filter system nitpicker } {
	set ingredient [single_ingredient $config "default"]
	if {$ingredient != ""} {
		set from [ingredient_path $config $ingredient]
		set to   [managed_config_path $config]
		check_syntax $from
		copy_config $from $to
	}
}

copy_config [file join [initial_config_dir] fb] [managed_config_path fb]


#
# VERSION file at the root of the config fs, add newline for 'cat /VERSION'
#

set fd [open [initial_config_file VERSION] w]
puts $fd "[sculpt_version]"
close $fd

# supply VERSION as a boot module to the sculpt manager
file copy [initial_config_file VERSION] [run_dir]/genode/VERSION


#
# Generate build info as boot module
#

proc build_date { } { return [clock format [clock seconds] -format %Y-%m-%d] }

proc genode_version { } {

	if {[have_installed git] && [file exists [file join [genode_dir] .git]]} {
		return [exec [installed_command git] -C [genode_dir] describe \
		       {--dirty= <local changes>} 2> /dev/null] }

	set fh [open [file join [genode_dir] VERSION] "RDONLY"]
	set version [read $fh]
	close $fh

	regsub -all {\s} $version "" version
	return $version
}

set    build_info "build_info"
append build_info "  genode_version: [genode_version]"
append build_info "  date:           [build_date]"
append build_info "  depot_user:     [depot_user]"
append build_info "  board:          $board_var"
append build_info "  base:           [depot_user]/bin/[depot_spec]/[base_src]/[_current_depot_archive_version src [base_src]]"
append build_info "-"

set fd [open [run_dir]/genode/build_info w]
puts $fd $build_info
close $fd


##
# Return list of 'pkg' attribute values found in 'type' nodes in an XML or HRD file
#
proc pkg_attribute_values { file node_path } {

	set cmd [genode_dir]/tool/hid
	if {[looks_like_xml $file]} { lappend cmd "--import-xml" }

	set result [split [exec {*}$cmd get "$node_path | : pkg" $file] "\n"]
	return $result
}


##
# Return list of pkg archives reference by the launchers and deploy config
#
proc referenced_pkg_values { } {

	set values {}

	# scan launchers
	foreach launcher [ingredients_of_type launcher] {
		set path [file join [initial_config_dir] launcher $launcher]
		lappend values {*}[pkg_attribute_values $path launcher]
	}

	# scan presets
	foreach preset [ingredients_of_type presets] {
		set path [file join [initial_config_dir] presets $preset]
		lappend values {*}[pkg_attribute_values $path "config | + start"]
	}

	# scan deploy config
	lappend values {*}[pkg_attribute_values [initial_config_file deploy] "config | + start"]

	return [lsort -unique $values]
}


#
# Replace pkg values of the form "name" by the form "user/pkg/name" suitable as
# arguments for '_collect_from_depot'.
#
proc pkg_archive_paths { values } {

	set result {}
	foreach value $values {
		if {[regexp {/} $value dummy]} {
			lappend result $value
		} else {
			lappend result "[depot_user]/pkg/$value"
		}
	}
	return $result
}


##
# Return which kind of depot archive is wanted: 'tar', 'omit', or 'list'
#
# tar  - includes the depot content referenced by the deploy configuration as
#        tar archive named 'depot.tar'
#
# omit - skips the evaluation of the deploy configuration
#
# list - outputs the list of packages needed for the deployment, which can
#        taken as input for manually publishing those packages
#
proc depot_archive { } {

	global ::env

	set archive "tar"
	if {[info exists ::env(DEPOT)]} {
		set archive "$::env(DEPOT)" }

	if {$archive != "omit" && $archive != "tar" && $archive != "list"} {
		puts stderr "Error: invalid value of DEPOT=$archive variable!" }

	return $archive
}


#
# Trigger the creation / updating of referenced depot content
#
# This step may update pkg versions if '--depot-auto-update' is enabled.
#
if {[depot_archive] == "tar" || [depot_archive] == "list"} {
	_collect_from_depot [pkg_archive_paths [referenced_pkg_values]]
}


#
# Augment deploy config or launcher file with current package versions
#

proc current_pkg { pkg } { return $pkg/[_current_depot_archive_version pkg $pkg] }


proc versioned_pkg { pkg } {

	if {[regexp [_depot_archive_versioned_path_pattern] $pkg dummy user type] && $type == "pkg"} {
		return $pkg
	} elseif {[regexp [_depot_archive_path_pattern] $pkg dummy user type name] && $type == "pkg"} {
		return $user/pkg/[current_pkg $name]
	} elseif {![regexp {/} $pkg dummy]} {
		return [depot_user]/pkg/[current_pkg $pkg]
	} else {
		puts stderr "Error: malformed depot-archive path '$pkg',"
		puts stderr "       expected '<user>/pkg/<name>' or"
		puts stderr "                '<name>' or"
		puts stderr "                '<user>/pkg/<name>/<version>'"
		exit
	}
}


proc augment_launcher_pkg_version { path } {

	set cmd [genode_dir]/tool/hid
	if {[looks_like_xml $path]} { lappend cmd --import-xml --output-xml }

	if {[catch {
		set pkg [exec {*}$cmd get "launcher | : pkg" $path]
		exec {*}$cmd -i set "launcher | : pkg: [versioned_pkg $pkg]" $path
	}]} {
		puts stderr "failed to parse $path for augmenting pkg versions"
		exit
	}
}


proc augment_start_node_pkg_versions { path } {

	set cmd [genode_dir]/tool/hid
	if {[looks_like_xml $path]} { lappend cmd --import-xml --output-xml }

	if {[catch {
		set names [split [exec {*}$cmd get "config | + start | : name" $path] "\n"]

		foreach name $names {
			set pkg [exec {*}$cmd get "config | + start $name | : pkg" $path]
			if {$pkg != ""} { # skip launcher start node
				exec {*}$cmd -i set "config | + start $name | : pkg: [versioned_pkg $pkg]" $path
			}
		}
	}]} {
		puts stderr "failed to parse $path for augmenting pkg versions"
		exit
	}
}


# launcher snippets
foreach launcher [ingredients_of_type launcher] {
	augment_launcher_pkg_version [file join [initial_config_dir] launcher $launcher] }

# presets
foreach preset [ingredients_of_type presets] {
	augment_start_node_pkg_versions [file join [initial_config_dir] presets $preset] }

# deploy config
augment_start_node_pkg_versions [initial_config_file deploy]

# update arch attribute of deploy config and presets
proc augment_arch_attribute { file } {
	set cmd [genode_dir]/tool/hid
	if {[looks_like_xml $file]} { lappend cmd --import-xml --output-xml }
	exec {*}$cmd -i set "config | : arch: [depot_spec]" $file
}

foreach preset [ingredients_of_type presets] {
	augment_arch_attribute [file join [initial_config_dir] presets $preset] }

augment_arch_attribute [initial_config_file deploy]


##
## Depot content integrated in the Sculpt image
##

proc create_depot_archive { } {

	if {[depot_archive] == "tar"} {
		create_tar_from_depot_binaries [run_dir]/genode/depot.tar \
                               {*}[pkg_archive_paths [referenced_pkg_values]]

	} else {
		create_tar_from_depot_binaries [run_dir]/genode/depot.tar
		if {[depot_archive] == "list"} {
			puts "Do not forget to publish:"
			puts [pkg_archive_paths [referenced_pkg_values]]
		}
	}
}

create_depot_archive


#
# Create initial_config.tar to be mounted at the root of the config fs
#

exec sh -c "tar cf [run_dir]/genode/initial_config.tar -C [initial_config_dir] ."

file delete -force [initial_config_dir]


##
## Auxiliary boot modules
##

#
# Linux-specific tweaks
#
if {[have_board linux]} {

	#
	# The Linux version of core does not export a platform_info ROM module.
	#
	install_boot_module "platform_info" "platform\n-\n"
}


if {[have_spec linux] || [have_spec fiasco] || [have_spec foc]} {
	#
	# Managed dataspaces as used by cached_fs_rom are not supported fully
	# on all kernels.
	#
	copy_file [run_dir]/genode/fs_rom [run_dir]/genode/cached_fs_rom
}

# support for the Leitzentrale GUI
copy_file [genode_dir]/repos/gems/src/app/backdrop/genode_logo.png [run_dir]/genode/
copy_file [genode_dir]/repos/gems/run/sculpt/drop_shadow.png       [run_dir]/genode/


#
# Generate depot index from gems/run/sculpt/index
#

set fd [open [genode_dir]/repos/gems/run/sculpt/index r]
set pkg_index [read $fd]
close $fd

# filter 'pkg' attribute
set pattern {(\<pkg[^\>]+?path=")([^/]+)(")}
while {[regexp $pattern $pkg_index dummy head pkg tail]} {
	set pkg_path [depot_user]/pkg/[current_pkg $pkg]
	regsub $pattern $pkg_index "$head$pkg_path$tail" pkg_index
}

# write filtered pkg index into the depot
file mkdir [depot_dir]/[depot_user]/index
set fd [open [depot_dir]/[depot_user]/index/[sculpt_version] w]
puts $fd $pkg_index
close $fd


##
## Create boot image
##

build [ingredients_of_type build]

append boot_modules [build_artifacts]

build_boot_image $boot_modules
